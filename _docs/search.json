[
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "debuggable utils",
    "section": "",
    "text": "import fastcore.meta as fm\nimport fastai.basics as fb\nfrom nbdev.showdoc import *\n\n\n\n\n\n whatinside (mo, dun:bool=False, func:bool=False, clas:bool=False,\n             bltin:bool=False, lib:bool=False, cal:bool=False)\n\nCheck what inside a module: all, functions, classes, builtins, and callables\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmo\n\n\nmodule, e.g., import fastcore.all as fa, use fa here\n\n\ndun\nbool\nFalse\nprint all items in all\n\n\nfunc\nbool\nFalse\nprint all user defined functions\n\n\nclas\nbool\nFalse\nprint all class objects\n\n\nbltin\nbool\nFalse\nprint all builtin funcs or methods\n\n\nlib\nbool\nFalse\nprint all the modules of the library it belongs to\n\n\ncal\nbool\nFalse\nprint all callables\n\n\n\n\ndef whatinside(mo, # module, e.g., `import fastcore.all as fa`, use `fa` here\n               dun:bool=False, # print all items in __all__\n               func:bool=False, # print all user defined functions\n               clas:bool=False, # print all class objects\n               bltin:bool=False, # print all builtin funcs or methods\n               lib:bool=False, # print all the modules of the library it belongs to\n               cal:bool=False # print all callables\n             ): \n    'Check what inside a module: __all__, functions, classes, builtins, and callables'\n    dun_all = len(mo.__all__) if hasattr(mo, \"__all__\") else 0\n    funcs = getmembers(mo, isfunction)\n    classes = getmembers(mo, isclass)\n    builtins = getmembers(mo, isbuiltin)\n    callables = getmembers(mo, callable)\n    pkgpath = os.path.dirname(mo.__file__)\n    print(f\"{mo.__name__} has: \\n{dun_all} items in its __all__, and \\n{len(funcs)} user defined functions, \\n{len(classes)} classes or class objects, \\n{len(builtins)} builtin funcs and methods, and\\n{len(callables)} callables.\\n\")  \n    if hasattr(mo, \"__all__\") and dun: pprint(mo.__all__)\n    if func: \n        print(f'The user defined functions are:')\n        pprint([i[0] for i in funcs])\n    if clas: \n        print(f'The class objects are:')\n        pprint([i[0] for i in classes])\n    if bltin: \n        print(f'The builtin functions or methods are:')\n        pprint([i[0] for i in builtins])\n    if cal: \n        print(f'The callables are: ')\n        pprint([i[0] for i in callables])\n    if lib: \n        modules = [name for _, name, _ in pkgutil.iter_modules([pkgpath])]\n        print(f'The library has {len(modules)} modules')\n        pprint(modules)\n\nwhatinside(fm, func=True)\n\nfastcore.meta has: \n13 items in its __all__, and \n43 user defined functions, \n19 classes or class objects, \n2 builtin funcs and methods, and\n74 callables.\n\nThe user defined functions are:\n['_funcs_kwargs',\n '_mk_param',\n '_rm_self',\n 'all_equal',\n 'anno_dict',\n 'any_is_instance',\n 'array_equal',\n 'contextmanager',\n 'copy',\n 'delegates',\n 'df_equal',\n 'empty2none',\n 'equals',\n 'funcs_kwargs',\n 'in_colab',\n 'in_ipython',\n 'in_jupyter',\n 'in_notebook',\n 'ipython_shell',\n 'is_close',\n 'is_coll',\n 'is_iter',\n 'isinstance_str',\n 'method',\n 'nequals',\n 'noop',\n 'noops',\n 'remove_prefix',\n 'remove_suffix',\n 'test',\n 'test_close',\n 'test_eq',\n 'test_eq_type',\n 'test_fail',\n 'test_fig_exists',\n 'test_is',\n 'test_ne',\n 'test_shuffled',\n 'test_sig',\n 'test_stdout',\n 'test_warns',\n 'use_kwargs',\n 'use_kwargs_dict']\n\n\n\nwhatinside(fb, bltin=True)\n\nfastai.basics has: \n0 items in its __all__, and \n430 user defined functions, \n237 classes or class objects, \n4 builtin funcs and methods, and\n696 callables.\n\nThe builtin functions or methods are:\n['array', 'as_tensor', 'reduce', 'warn']\n\n\n\nwhatinside(fb, lib=True)\n\nfastai.basics has: \n0 items in its __all__, and \n430 user defined functions, \n237 classes or class objects, \n4 builtin funcs and methods, and\n696 callables.\n\nThe library has 24 modules\n['_modidx',\n '_nbdev',\n '_pytorch_doc',\n 'basics',\n 'callback',\n 'collab',\n 'data',\n 'distributed',\n 'fp16_utils',\n 'imports',\n 'interpret',\n 'layers',\n 'learner',\n 'losses',\n 'medical',\n 'metrics',\n 'optimizer',\n 'tabular',\n 'test_utils',\n 'text',\n 'torch_basics',\n 'torch_core',\n 'torch_imports',\n 'vision']"
  },
  {
    "objectID": "utils.html#find-out-the-version-of-a-library",
    "href": "utils.html#find-out-the-version-of-a-library",
    "title": "debuggable utils",
    "section": "Find out the version of a library",
    "text": "Find out the version of a library\n\nwhichversion source\n\n\n\nwhichversion\n\n whichversion (libname:str, req:bool=False, file:bool=False)\n\nGive you library version and other basic info.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlibname\nstr\n\nlibrary name\n\n\nreq\nbool\nFalse\nprint lib requirements\n\n\nfile\nbool\nFalse\nprint all lib files\n\n\n\n\npprint(getsource(whichversion))\n\n('def whichversion(libname:str, # library name\\n'\n '                req:bool=False, # print lib requirements \\n'\n '                file:bool=False): # print all lib files\\n'\n '    \"Give you library version and other basic info.\"\\n'\n \"    if libname=='python':\\n\"\n '        print(f\"python: {python_version()}\")\\n'\n '    else: \\n'\n '        print(f\"{metadata(libname)[\\'Name\\']}: {version(libname)} '\n \"\\\\n{metadata(libname)['Summary']}\\\\\\n\"\n \"    \\\\n{metadata(libname)['Author']} \\\\n{metadata(libname)['Home-page']} \\\\\\n\"\n \"    \\\\npython_version: {metadata(libname)['Requires-Python']} \\\\\\n\"\n '    \\\\n{distribution(libname).locate_file(libname)}\")\\n'\n '\\n'\n '    if req: \\n'\n '        print(f\"\\\\n{libname} requires: \")\\n'\n '        pprint(distribution(libname).requires)\\n'\n '    if file: \\n'\n '        print(f\"\\\\n{libname} has: \")\\n'\n '        pprint(distribution(libname).files)\\n')\n\n\nfrom importlib.metadata import version, metadata, distribution\nfrom platform import python_version \n\ndef whichversion(libname:str, # library name\n                req:bool=False, # print lib requirements \n                file:bool=False): # print all lib files\n    \"Give you library version and other basic info.\"\n    if libname=='python':\n        print(f\"python: {python_version()}\")\n    else: \n        print(f\"{metadata(libname)['Name']}: {version(libname)} \\n{metadata(libname)['Summary']}\\\n    \\n{metadata(libname)['Author']} \\n{metadata(libname)['Home-page']} \\\n    \\npython_version: {metadata(libname)['Requires-Python']} \\\n    \\n{distribution(libname).locate_file(libname)}\")\n\n    if req: \n        print(f\"\\n{libname} requires: \")\n        pprint(distribution(libname).requires)\n    if file: \n        print(f\"\\n{libname} has: \")\n        pprint(distribution(libname).files)\n\nHow to break a line in python code\nsee the code above\n\n\n\nwhichversion examples\n\nwhichversion('python')\n\npython: 3.9.13\n\n\n\nwhichversion('fastcore')\n\nfastcore: 1.5.22 \nPython supercharged for fastai development    \nJeremy Howard and Sylvain Gugger \nhttps://github.com/fastai/fastcore/     \npython_version: >=3.7     \n/Users/Natsume/mambaforge/lib/python3.9/site-packages/fastcore\n\n\n\nwhichversion('nbdev')\n\nnbdev: 2.2.6 \nCreate delightful software with Jupyter Notebooks    \nJeremy Howard and Hamel Husain \nhttps://github.com/fastai/nbdev     \npython_version: >=3.7     \n/Users/Natsume/mambaforge/lib/python3.9/site-packages/nbdev\n\n\n\nwhichversion('nbdev', req=True)\n\nnbdev: 2.2.6 \nCreate delightful software with Jupyter Notebooks    \nJeremy Howard and Hamel Husain \nhttps://github.com/fastai/nbdev     \npython_version: >=3.7     \n/Users/Natsume/mambaforge/lib/python3.9/site-packages/nbdev\n\nnbdev requires: \n['fastcore (>=1.5.19)',\n 'execnb (>=0.0.10)',\n 'astunparse',\n 'ghapi',\n 'PyYAML',\n 'asttokens ; python_version==\"3.7\"',\n \"nbdev-numpy ; extra == 'dev'\",\n \"nbdev-stdlib ; extra == 'dev'\",\n \"pandas ; extra == 'dev'\",\n \"matplotlib ; extra == 'dev'\",\n \"black ; extra == 'dev'\"]\n\n\n\nwhichversion('nbdev', file=True)\n\nnbdev: 2.2.6 \nCreate delightful software with Jupyter Notebooks    \nJeremy Howard and Hamel Husain \nhttps://github.com/fastai/nbdev     \npython_version: >=3.7     \n/Users/Natsume/mambaforge/lib/python3.9/site-packages/nbdev\n\nnbdev has: \n[PackagePath('../../../bin/nbdev_bump_version'),\n PackagePath('../../../bin/nbdev_changelog'),\n PackagePath('../../../bin/nbdev_clean'),\n PackagePath('../../../bin/nbdev_conda'),\n PackagePath('../../../bin/nbdev_create_config'),\n PackagePath('../../../bin/nbdev_deploy'),\n PackagePath('../../../bin/nbdev_docs'),\n PackagePath('../../../bin/nbdev_export'),\n PackagePath('../../../bin/nbdev_filter'),\n PackagePath('../../../bin/nbdev_fix'),\n PackagePath('../../../bin/nbdev_help'),\n PackagePath('../../../bin/nbdev_install'),\n PackagePath('../../../bin/nbdev_install_hooks'),\n PackagePath('../../../bin/nbdev_install_quarto'),\n PackagePath('../../../bin/nbdev_merge'),\n PackagePath('../../../bin/nbdev_migrate'),\n PackagePath('../../../bin/nbdev_new'),\n PackagePath('../../../bin/nbdev_prepare'),\n PackagePath('../../../bin/nbdev_preview'),\n PackagePath('../../../bin/nbdev_pypi'),\n PackagePath('../../../bin/nbdev_quarto'),\n PackagePath('../../../bin/nbdev_readme'),\n PackagePath('../../../bin/nbdev_release_both'),\n PackagePath('../../../bin/nbdev_release_gh'),\n PackagePath('../../../bin/nbdev_release_git'),\n PackagePath('../../../bin/nbdev_sidebar'),\n PackagePath('../../../bin/nbdev_test'),\n PackagePath('../../../bin/nbdev_trust'),\n PackagePath('../../../bin/nbdev_update'),\n PackagePath('nbdev-2.2.6.dist-info/INSTALLER'),\n PackagePath('nbdev-2.2.6.dist-info/LICENSE'),\n PackagePath('nbdev-2.2.6.dist-info/METADATA'),\n PackagePath('nbdev-2.2.6.dist-info/RECORD'),\n PackagePath('nbdev-2.2.6.dist-info/REQUESTED'),\n PackagePath('nbdev-2.2.6.dist-info/WHEEL'),\n PackagePath('nbdev-2.2.6.dist-info/entry_points.txt'),\n PackagePath('nbdev-2.2.6.dist-info/top_level.txt'),\n PackagePath('nbdev/__init__.py'),\n PackagePath('nbdev/__pycache__/__init__.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/_modidx.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/clean.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/cli.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/config.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/doclinks.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/export.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/extract_attachments.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/frontmatter.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/imports.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/maker.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/merge.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/migrate.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/mkdocs.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/process.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/processors.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/qmd.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/quarto.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/release.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/showdoc.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/sync.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/test.cpython-39.pyc'),\n PackagePath('nbdev/__pycache__/tutorial.cpython-39.pyc'),\n PackagePath('nbdev/_modidx.py'),\n PackagePath('nbdev/clean.py'),\n PackagePath('nbdev/cli.py'),\n PackagePath('nbdev/config.py'),\n PackagePath('nbdev/doclinks.py'),\n PackagePath('nbdev/export.py'),\n PackagePath('nbdev/extract_attachments.py'),\n PackagePath('nbdev/frontmatter.py'),\n PackagePath('nbdev/imports.py'),\n PackagePath('nbdev/maker.py'),\n PackagePath('nbdev/merge.py'),\n PackagePath('nbdev/migrate.py'),\n PackagePath('nbdev/mkdocs.py'),\n PackagePath('nbdev/process.py'),\n PackagePath('nbdev/processors.py'),\n PackagePath('nbdev/qmd.py'),\n PackagePath('nbdev/quarto.py'),\n PackagePath('nbdev/release.py'),\n PackagePath('nbdev/showdoc.py'),\n PackagePath('nbdev/sync.py'),\n PackagePath('nbdev/test.py'),\n PackagePath('nbdev/tutorial.py')]"
  },
  {
    "objectID": "utils.html#print-out-info-during-debugging",
    "href": "utils.html#print-out-info-during-debugging",
    "title": "debuggable utils",
    "section": "print out info during debugging",
    "text": "print out info during debugging\nNice tutorial on how to use eval\n\neval?\n\n\nSignature: eval(source, globals=None, locals=None, /)\nDocstring:\nEvaluate the given source in the context of globals and locals.\nThe source may be a string representing a Python expression\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it.\nType:      builtin_function_or_method\n\n\n\n\n\nexec?\n\n\nSignature: exec(source, globals=None, locals=None, /)\nDocstring:\nExecute the given source in the context of globals and locals.\nThe source may be a string representing one or more Python statements\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it.\nType:      builtin_function_or_method\n\n\n\n\n\ndbprint to display evalutaion\n\ndef dbprint(name:str, *code, **env):\n    print(f\"\\n{name}:==============================\")\n    for c in code:\n        if \"=\" in c:\n            exec(c)\n            variable = c.partition(\"=\")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n        else: \n            print(f\"{c}: {eval(c, {}, {**env})}\")\n\n\ndef low(a, b=1): pass\ndef mid(c, d=1, **kwargs): pass\nfrom_f = mid\nto_f = low\n\n\ndbprint(\"getattr(from_f,'__func__',from_f)\", \"k = hasattr(from_f, '__func__')\", \"hasattr(to_f, '__func__')\", \"to_f\", \"from_f\", from_f=from_f, to_f=to_f)\n\n\ngetattr(from_f,'__func__',from_f):==============================\nk = hasattr(from_f, '__func__') => k : False\nhasattr(to_f, '__func__'): False\nto_f: <function low>\nfrom_f: <function mid>\n\n\n\ndef test():\n    def t1(): pass\n    def t2(): pass\n    from_f = t1\n    to_f = t2\n    dbprint(\"getattr(from_f,'__func__',from_f)\", \"hasattr(from_f, '__func__')\", \"hasattr(to_f, '__func__')\", \"to_f\", \"from_f\", from_f=from_f, to_f=to_f)\n\ntest()\n\n\ngetattr(from_f,'__func__',from_f):==============================\nhasattr(from_f, '__func__'): False\nhasattr(to_f, '__func__'): False\nto_f: <function test.<locals>.t2>\nfrom_f: <function test.<locals>.t1>\n\n\n\n\ndbprint to handle assignment too\n\n\"=\" in \"a = 1\"\n\nTrue\n\n\n\nfrom math import *\nexec(\"print(dir())\", globals())\n\n['AutoInit', 'BasicHtmlRenderer', 'BasicMarkdownRenderer', 'BuiltinFunctionType', 'BuiltinMethodType', 'BypassNewMeta', 'Dict', 'DocmentTbl', 'FixSigMeta', 'FunctionType', 'Generator', 'IN_COLAB', 'IN_IPYTHON', 'IN_JUPYTER', 'IN_NOTEBOOK', 'In', 'Iterable', 'Iterator', 'List', 'MethodDescriptorType', 'MethodType', 'MethodWrapperType', 'NewChkMeta', 'NoneType', 'Optional', 'Out', 'Path', 'PrePostInitMeta', 'Sequence', 'Set', 'ShowDocRenderer', 'SimpleNamespace', 'Tuple', 'Union', 'WrapperDescriptorType', '_', '__', '___', '__builtin__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', '_dh', '_ih', '_oh', 'acos', 'acosh', 'all_equal', 'anno_dict', 'any_is_instance', 'array_equal', 'asin', 'asinh', 'ast', 'atan', 'atan2', 'atanh', 'attrgetter', 'ceil', 'colab_link', 'comb', 'copysign', 'cos', 'cosh', 'degrees', 'delegates', 'df_equal', 'dist', 'distribution', 'doc', 'e', 'empty2none', 'enum', 'equals', 'erf', 'erfc', 'exit', 'exp', 'expm1', 'fabs', 'factorial', 'fb', 'floor', 'fm', 'fmod', 'frexp', 'fsum', 'funcs_kwargs', 'functools', 'gamma', 'gcd', 'get_ipython', 'getmembers', 'getsource', 'hypot', 'in_colab', 'in_ipython', 'in_jupyter', 'in_notebook', 'inf', 'inspect', 'io', 'ipython_shell', 'is_coll', 'is_iter', 'isbuiltin', 'isclass', 'isclose', 'isfinite', 'isfunction', 'isinf', 'isinstance_str', 'isnan', 'isqrt', 'itemgetter', 'itertools', 'lcm', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'math', 'metadata', 'method', 'modf', 'nan', 'nextafter', 'noop', 'noops', 'operator', 'os', 'partial', 'perm', 'pi', 'pkgutil', 'pow', 'pprint', 'prod', 'python_version', 'quit', 'radians', 're', 'reduce', 'remainder', 'remove_prefix', 'remove_suffix', 'show_doc', 'showdoc_nm', 'sin', 'sinh', 'sqrt', 'string_classes', 'sys', 'tan', 'tanh', 'tau', 'test_sig', 'trunc', 'typing', 'ulp', 'use_kwargs', 'use_kwargs_dict', 'version', 'warn', 'warnings', 'whatinside', 'whichversion']\n\n\n\nfrom math import *\nexec(\"print(dir())\", {}, {\"sum\": sum, \"print\": print, \"dir\": dir, \"c\": 1})\n\n['c', 'dir', 'print', 'sum']\n\n\n\nfrom math import *\nexec(\"print(dir())\", {\"__builtins__\" : __builtin__}, {\"sum\": sum, \"print\": print, \"dir\": dir, \"c\": 1})\n\n['c', 'dir', 'print', 'sum']\n\n\n\nfrom math import *\nexec(\"print(dir())\", globals(), {\"sum\": sum, \"print\": print, \"dir\": dir, \"c\": 1})\n\n['c', 'dir', 'print', 'sum']\n\n\n\nexec(\"e = 2 + 4\")\neval(\"e\")\n\n6\n\n\n\nexec(\"c = 2 + 9\", globals())\neval(\"c\")\n\n11\n\n\n\nexec(\"d = 2 + 10\", globals(), locals())\neval(\"d\")\n\n12\n\n\n\nexec(\"z = 2 + g\", globals(), locals().update({'g':3}))\neval(\"z\")\n\n5\n\n\n\nexec(\"c = 2 + f\", globals(), {'f':3})\neval(\"c\")\n\n11\n\n\n\nexec(\"c = 2 + f\", globals(), locals().update({'f':3}))\neval(\"c\")\n\n5\n\n\n\nexec(\"c = 2 + f\", globals().update({'f':4}), locals())\neval(\"c\")\n\n6\n\n\n\nexec(\"print (dir())\",{})\n\n['__builtins__']\n\n\n\nexec (\"print (dir())\",{}, {'a':1, 'b':2})\n\n['a', 'b']\n\n\n\nexec (\"print (dir())\", {'c':3}, {'a':1, 'b':2})\n\n['a', 'b']\n\n\n\n'f' in locals()\n\nTrue\n\n\n\nlocals().update({'f':1})\n\n\n'f' in locals()\n\nTrue\n\n\n\n\nThe simple working version\n\ndef dbprint(name:str, *code, **env):\n    print(f\"\\n{name}:==============================\")\n    for c in code:\n        if \"=\" in c: # updated to handle assignment\n            exec(c, globals(), locals().update(env)) \n            variable = c.partition(\"=\")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n        else: \n            print(f\"{c}: {eval(c, {}, {**env})}\") # working version\n\n\ndef dbprint(name:str, *code, **env):\n    print(f\"\\n{name}:==============================\")\n    for c in code:\n        if \"=\" in c: # updated to handle assignment\n            exec(c, globals(), locals().update(env)) \n            variable = c.partition(\"=\")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n        else: \n            print(f\"{c}: {eval(c, globals(), locals().update(env))}\") # problematic\n            # print(f\"{c}: {eval(c, globals().update(env), locals().update(env))}\")\n\n\na = 10\nstring = \"string\"\ndbprint(\"test assignment with exec and eval\", \"k = 1 + 2 + a\", a = a, string=string)\n\n\ntest assignment with exec and eval:==============================\nk = 1 + 2 + a => k : 13\n\n\n\na = 10\nstring = \"string\"\ndbprint(\"test assignment with exec and eval\", \"1 + 2 + a\", a = a, string=string)\n\n\ntest assignment with exec and eval:==============================\n1 + 2 + a: 13\n\n\n\ndef test():\n    def t1(): pass\n    def t2(): pass\n    from_f = t1\n    to_f = t2\n    dbprint(\"getattr(from_f,'__func__',from_f)\", \"hasattr(from_f, '__func__')\", \"hasattr(to_f, '__func__')\", \"to_f\", \"from_f\", from_f=from_f, to_f=to_f)\n\ntest()\n\n\ngetattr(from_f,'__func__',from_f):==============================\nhasattr(from_f, '__func__'): False\nhasattr(to_f, '__func__'): False\nto_f: <function low>\nfrom_f: <function mid>\n\n\n\ndef low(a, b=1): pass\ndef mid(c, d=1, **kwargs): pass\nfrom_f = mid\nto_f = low\n\n\ndbprint(\"getattr(from_f,'__func__',from_f)\", \"k = hasattr(from_f, '__func__')\", \"hasattr(to_f, '__func__')\", \"to_f\", \"from_f\", from_f=from_f, to_f=to_f)\n\n\ngetattr(from_f,'__func__',from_f):==============================\nk = hasattr(from_f, '__func__') => k : False\nhasattr(to_f, '__func__'): False\nto_f: <function low>\nfrom_f: <function mid>\n\n\n\n\nA working version but slightly longer\n\ndef dbprint(name:str, *code, **env):\n    print(f\"\\n{name}:==============================\")\n    for c in code:\n        if \"=\" in c: # updated to handle assignment\n            exec(c, globals(), locals().update(env)) \n            variable = c.partition(\"=\")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n        else: \n            # print(f\"{c}: {eval(c, globals().update(env), locals().update(env))}\") # working too\n            print(f\"{c}: {eval(c, globals().update(env))}\") # working too\n\n\na = 10\nstring = \"string\"\ndbprint(\"test assignment with exec and eval\", \"k = 1 + 2 + a\", a = a, string=string)\n\n\ntest assignment with exec and eval:==============================\nk = 1 + 2 + a => k : 13\n\n\n\na = 10\nstring = \"string\"\ndbprint(\"test assignment with exec and eval\", \"1 + 2 + a\", a = a, string=string)\n\n\ntest assignment with exec and eval:==============================\n1 + 2 + a: 13\n\n\n\ndef test():\n    def t1(): pass\n    def t2(): pass\n    from_f = t1\n    to_f = t2\n    dbprint(\"getattr(from_f,'__func__',from_f)\", \"hasattr(from_f, '__func__')\", \"hasattr(to_f, '__func__')\", \"to_f\", \"from_f\", from_f=from_f, to_f=to_f)\n\ntest()\n\n\ngetattr(from_f,'__func__',from_f):==============================\nhasattr(from_f, '__func__'): False\nhasattr(to_f, '__func__'): False\nto_f: <function test.<locals>.t2>\nfrom_f: <function test.<locals>.t1>\n\n\n\ndef low(a, b=1): pass\ndef mid(c, d=1, **kwargs): pass\nfrom_f = mid\nto_f = low\n\n\ndbprint(\"getattr(from_f,'__func__',from_f)\", \"k = hasattr(from_f, '__func__')\", \"hasattr(to_f, '__func__')\", \"to_f\", \"from_f\", from_f=from_f, to_f=to_f)\n\n\ngetattr(from_f,'__func__',from_f):==============================\nk = hasattr(from_f, '__func__') => k : False\nhasattr(to_f, '__func__'): False\nto_f: <function low>\nfrom_f: <function mid>\n\n\n\n\nexec and eval’s locals has priority over global\n\n'x' in globals()\n\nFalse\n\n\n\n'x' in locals()\n\nFalse\n\n\n\nglobals()['x'] = 0\nglobals()['x']\n\n0\n\n\n\nlocals()['x'] = 1\nlocals()['x']\n\n1\n\n\n\nglobals()['x']\n\n1\n\n\n\nexec(\"x = x + 1\", globals())\neval(\"x\")\n\n2\n\n\n\nexec(\"x = x + 1\", globals(), locals())\neval(\"x\")\n\n3\n\n\n\nexec(\"x = x + 1\", globals(), locals().update({'x':10}))\neval(\"x\")\n\n11\n\n\n\nexec(\"x = x + 1\", globals().update({'x':20}), locals().update({'x':10}))\neval(\"x\")\n\n11\n\n\n\nexec(\"x = x + 1\", globals().update({'x':20}))\neval(\"x\")\n\n21\n\n\n\ndef dbprint(name:str, *code, **env):\n    print(f\"\\n{name}:==============================\")\n    for c in code:\n        if \"=\" in c: # updated to handle assignment\n            exec(c, globals(), locals().update(env)) \n            variable = c.partition(\"=\")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n        else: \n            # print(f\"{c}: {eval(c, globals().update(env), locals().update(env))}\") # working too\n            # print(f\"{c}: {eval(c, globals().update(env))}\") # working too\n            print(f\"{c}: {eval(c, globals(), locals().update(env))}\") # working too\n\n\na = 10\nstring = \"string\"\ndbprint(\"test assignment with exec and eval\", \"k = 1 + 2 + a\", a = a, string=string)\n\n\ntest assignment with exec and eval:==============================\nk = 1 + 2 + a => k : 13\n\n\n\na = 5\nstring = \"string\"\ndbprint(\"test assignment with exec and eval\", \"1 + 2 + a\", a = a, string=string)\n\n\ntest assignment with exec and eval:==============================\n1 + 2 + a: 8\n\n\n\nglobals()['from_f']\n\n<function __main__.mid(c, d=1, **kwargs)>\n\n\n\nlocals()['from_f']\n\n<function __main__.mid(c, d=1, **kwargs)>\n\n\n\ndef t1(): pass\ndef t2(): pass\nfrom_f = t1\nto_f = t2\ndbprint(\"getattr(from_f,'__func__',from_f)\", \"hasattr(from_f, '__func__')\", \"hasattr(to_f, '__func__')\", \"to_f\", \"from_f\", from_f=t1, to_f=t2)\n\n\ngetattr(from_f,'__func__',from_f):==============================\nhasattr(from_f, '__func__'): False\nhasattr(to_f, '__func__'): False\nto_f: <function t2>\nfrom_f: <function t1>\n\n\n\ndef low(a, b=1): pass\ndef mid(c, d=1, **kwargs): pass\nfrom_f = mid\nto_f = low\n\n\ndbprint(\"getattr(from_f,'__func__',from_f)\", \"k = hasattr(from_f, '__func__')\", \"hasattr(to_f, '__func__')\", \"to_f\", \"from_f\", from_f=from_f, to_f=to_f)\n\n\ngetattr(from_f,'__func__',from_f):==============================\nk = hasattr(from_f, '__func__') => k : False\nhasattr(to_f, '__func__'): False\nto_f: <function low>\nfrom_f: <function mid>\n\n\n\n\nA trial and error version\nAll the versions above seem working for the tests above, but the following one works for the real debugging codes\n\ndef dbprint(name:str, *code, **env): \n    print(f\"\\n{name}:==============================\")\n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        \n        # handle assignment\n        if \"=\" in c: \n            # print('k' in locals())\n            exec(c, globals().update(env)) \n            # print('k' in locals())\n            variable = c.partition(\"=\")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n        \n        # handle evaluation\n        else: \n            print(f\"{c}: {eval(c, globals().update(env))}\") \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\n\nto differentiate between assignment and != and ==\n\ndef dbprint(src:str, # the source to debug in str\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            **env):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\"\n    \n    print(f\"\\n{src}:==============================\")\n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        \n        # handle assignment\n        if \" = \" in c: # make sure assignment and !== and == are differentiated\n            \n            # print('k' in locals())\n            exec(c, globals().update(env)) \n            # print('k' in locals())\n            variable = c.partition(\" = \")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n        \n        # handle evaluation\n        else: \n            print(f\"{c}: {eval(c, globals().update(env))}\") \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\n\"k.__delopt__ = {...}\".partition(\" = \")[0]\n\n'k.__delopt__'\n\n\n\ndbprint(\"tests = and != in the same line\", \"a = 5 == 4\")\n\n\ntests = and != in the same line:==============================\na = 5 == 4 => a: False\n\n\n\ndbprint(\"tests = and != in the same line\", \"a = 5 != 4\")\n\n\ntests = and != in the same line:==============================\na = 5 != 4 => a: True\n\n\n\n\nhandle if statement\n\ndef dbprint(src:str, # the source to debug in str\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            **env):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\"\n    \n    print(f\"\\n{src}:==============================\")\n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        \n        # handle assignment\n        if \" = \" in c: # make sure assignment and !== and == are differentiated\n            \n            # print('k' in locals())\n            exec(c, globals().update(env)) \n            # print('k' in locals())\n            variable = c.partition(\" = \")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n            \n        # handle if statement\n        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must\n        elif \"if\" in c: \n            cond = re.search('if (.*?):', c).group(1)\n            if eval(cond):\n                print(f\"{c} => \")\n                exec(c, globals().update(env))\n        \n        # handle evaluation\n        else: \n            print(f\"{c}: {eval(c, globals().update(env))}\") \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\nx = 100\nexec(\"if x: print(x)\")\n\n100\n\n\n\nimport re\n\nc = 'if abc == def: print()'\n\ncond = re.search('if (.*?):', c).group(1)\ncond\n\n'abc == def'\n\n\n\n\nHandle for in loop and in-block printing\n\n\n\nchecksource\n\n checksource ()\n\n\ndefaults.src2dbp.delegates.append(('ab', 'cd'))\n\n\ndefaults.src2dbp.delegates\n\n[('ab', 'cd')]\n\n\n\ndef dbprint(src:str, # the source to debug in str\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            **env\n           ):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution 1: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\\\n    Caution 2: make sure the include all the necessary env variables to avoid \\\n    the same variable with different values from different scopes.\"\n    \n    # whether dbprint is working inside a for in loop or any kind of a loop\n    if defaults.block == True:\n        print(f\"\\n{src}:===inside a block===\") # inside a block\n    else:\n        print(f\"\\n{src}:================================================================================\") \n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        \n        # handle assignment\n        if \" = \" in c: # make sure assignment and !== and == are differentiated\n            \n            # print('k' in locals())\n            exec(c, globals().update(env)) \n            # print('k' in locals())\n            variable = c.partition(\" = \")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n            \n        # handle if statement\n        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must\n        elif \"if\" in c: \n            cond = re.search('if (.*?):', c).group(1)\n            \n            # when code in string is like 'if abc == def:'\n            if c.endswith(':'):\n                \n                # print ... \n                print(f\"{c} => {cond}: {eval(cond)}\")      \n                \n            # when code in string is like 'if abc == def: print(...)'\n            else: \n                # if the cond is true, then print ...\n                if eval(cond):\n                    \n                    # \"if abc == def: print(abc)\".split(': ', 2)[1] to get 'print(abc)'\n                    printc = c.split(': ', 1)[1]\n                    print(f\"{c} => {printc} : \")\n                    exec(c, globals().update(env))\n                    \n                # if cond is false, then print ...\n                else: \n                    print(f\"{c} => {cond}: {eval(cond)}\")\n                \n                \n        # handle for in statement\n        elif \"for \" in c and \" in \" in c: \n            \n            # if the code in string is like 'for k, v in abc:'\n            if c.endswith(':'):\n                \n                # get the substring between 'for ' and ' in', which is like 'k, v'\n                variables = re.search('for (.*?) in', c).group(1)\n                \n                # if variables has a substring like ', ' inside\n                if (', ') in variables: \n                    \n                    # split it by ', ' into a list of substrings\n                    vl = variables.split(', ')\n                    key = vl[0]\n                    value = vl[1]\n                    \n                    # make sure key and value will get evaluated first before exec run\n                    c1 = c + \" print(f'{key}:{eval(key)}, {value}:{eval(value)}')\" \n                    print(f\"{c} => \")          \n                    exec(c1, globals().update(env))\n                \n                else:\n                    c1 = c + \" print(f'item:{variables}')\"\n                    print(f\"{c} => \")          \n                    exec(c1, globals().update(env))\n                    \n\n            else: \n                print(f\"{c} => \")          \n                exec(c, globals().update(env))\n        \n        \n        # handle evaluation\n        else: \n            print(f\"{c} => {eval(c, globals().update(env))}\") \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\n\nclean up the format for readability\n\ndef dbprint(src:str, # the source to debug in str\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            **env\n           ):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution 1: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\\\n    Caution 2: make sure the include all the necessary env variables to avoid \\\n    the same variable with different values from different scopes.\"\n    \n    # whether dbprint is working inside a for in loop or any kind of a loop\n    if defaults.block == True:\n        print(f\"\\n{src}:===inside a block===\") # inside a block\n    else:\n        print(f\"\\n{src}:================================================================================\") \n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        \n        # handle assignment\n        if \" = \" in c: # make sure assignment and !== and == are differentiated\n            \n            # print('k' in locals())\n            exec(c, globals().update(env)) \n            # print('k' in locals())\n            variable = c.partition(\" = \")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n            \n        # handle if statement\n        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must\n        elif \"if\" in c: \n            cond = re.search('if (.*?):', c).group(1)\n            \n            # when code in string is like 'if abc == def:'\n            if c.endswith(':'):\n                \n                # print ... \n                print(f\"{c} => {cond}: {eval(cond)}\")      \n                \n            # when code in string is like 'if abc == def: print(...)'\n            else: \n                # if the cond is true, then print ...\n                if eval(cond):\n                    \n                    # \"if abc == def: print(abc)\".split(': ', 2)[1] to get 'print(abc)'\n                    printc = c.split(': ', 1)[1]\n                    print(f\"{c} => {printc} : \")\n                    exec(c, globals().update(env))\n                    \n                # if cond is false, then print ...\n                else: \n                    print(f\"{c} => {cond}: {eval(cond)}\")\n                \n                \n        # handle for in statement\n        elif \"for \" in c and \" in \" in c: \n            \n            # if the code in string is like 'for k, v in abc:'\n            if c.endswith(':'):\n                \n                # get the substring between 'for ' and ' in', which is like 'k, v'\n                variables = re.search('for (.*?) in', c).group(1)\n                \n                # if variables has a substring like ', ' inside\n                if (', ') in variables: \n                    \n                    # split it by ', ' into a list of substrings\n                    vl = variables.split(', ')\n                    key = vl[0]\n                    value = vl[1]\n                    \n                    # make sure key and value will get evaluated first before exec run\n                    # printc is for exec to run\n                    printc = \"print(f'{key}:{eval(key)}, {type(eval(key))} ; {value}:{eval(value)}, {type(eval(value))}')\" \n                    # printmsg is for reader to understand with ease\n                    printmsg = \"print(f'key: {key}, {type(key)} ; value: {value}, {type(value)}')\"\n                    c1 = c + \" \" + printc\n                    print(f\"{c} => {printmsg} : \")          \n                    exec(c1, globals().update(env))\n                \n                else:\n                    printc = \"print(f'{variables} : {eval(variables)}')\"\n                    printmsg = \"print(f'i : {variables}')\"\n                    c1 = c + \" \" + printc\n                    print(f\"{c} => {printmsg} : \")          \n                    exec(c1, globals().update(env))\n                    \n            # if the code in string is like 'for k, v in abc: print(abc)'\n            else:                 \n                # \"for k, v in abc: print(k)\".split(': ', 1)[1] to get 'print(k)'\n                printc = c.split(': ', 1)[1]\n                print(f\"{c} => {printc} : \")\n                exec(c, globals().update(env))\n        \n        \n        # handle evaluation\n        else: \n            print(f\"{c} : {eval(c, globals().update(env))}\") \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\n\nAdd a few more caution messages for avoiding unnecessary errors in using dbprint\n\ndef dbprint(src:str, # the source to debug in str\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            **env\n           ):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution 1: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\\\n    Caution 2: make sure to include all the necessary env variables to avoid \\\n    the same variable with different values from different scopes. Caution 3: when an env variable is updated, \\\n    then you need to includ it again in the next dbprint. Caution 4: be strict on the spaces, e.g., `for k, v in` \\\n    and `a = createsth(...)`\"\n    \n    # whether dbprint is working inside a for in loop or any kind of a loop\n    if defaults.block == True:\n        print(f\"\\n{src}:===inside a block===\") # inside a block\n    else:\n        print(f\"\\n{src}:================================================================================\") \n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        \n        # handle assignment\n        if \" = \" in c: # make sure assignment and !== and == are differentiated\n            \n            # print('k' in locals())\n            exec(c, globals().update(env)) \n            # print('k' in locals())\n            variable = c.partition(\" = \")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n            \n        # handle if statement\n        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must\n        elif \"if\" in c: \n            cond = re.search('if (.*?):', c).group(1)\n            \n            # when code in string is like 'if abc == def:'\n            if c.endswith(':'):\n                \n                # print ... \n                print(f\"{c} => {cond}: {eval(cond)}\")      \n                \n            # when code in string is like 'if abc == def: print(...)'\n            else: \n                # if the cond is true, then print ...\n                if eval(cond):\n                    \n                    # \"if abc == def: print(abc)\".split(': ', 2)[1] to get 'print(abc)'\n                    printc = c.split(': ', 1)[1]\n                    print(f\"{c} => {printc} : \")\n                    exec(c, globals().update(env))\n                    \n                # if cond is false, then print ...\n                else: \n                    print(f\"{c} => {cond}: {eval(cond)}\")\n                \n                \n        # handle for in statement\n        elif \"for \" in c and \" in \" in c: \n            \n            # if the code in string is like 'for k, v in abc:'\n            if c.endswith(':'):\n                \n                # get the substring between 'for ' and ' in', which is like 'k, v'\n                variables = re.search('for (.*?) in', c).group(1)\n                \n                # if variables has a substring like ', ' inside\n                if (', ') in variables: \n                    \n                    # split it by ', ' into a list of substrings\n                    vl = variables.split(', ')\n                    key = vl[0]\n                    value = vl[1]\n                    \n                    # make sure key and value will get evaluated first before exec run\n                    # printc is for exec to run\n                    printc = \"print(f'{key}:{eval(key)}, {type(eval(key))} ; {value}:{eval(value)}, {type(eval(value))}')\" \n                    # printmsg is for reader to understand with ease\n                    printmsg = \"print(f'key: {key}, {type(key)} ; value: {value}, {type(value)}')\"\n                    c1 = c + \" \" + printc\n                    print(f\"{c} => {printmsg} : \")          \n                    exec(c1, globals().update(env))\n                \n                else:\n                    printc = \"print(f'{variables} : {eval(variables)}')\"\n                    printmsg = \"print(f'i : {variables}')\"\n                    c1 = c + \" \" + printc\n                    print(f\"{c} => {printmsg} : \")          \n                    exec(c1, globals().update(env))\n                    \n            # if the code in string is like 'for k, v in abc: print(abc)'\n            else:                 \n                # \"for k, v in abc: print(k)\".split(': ', 1)[1] to get 'print(k)'\n                printc = c.split(': ', 1)[1]\n                print(f\"{c} => {printc} : \")\n                exec(c, globals().update(env))\n        \n        \n        # handle evaluation\n        else: \n            print(f\"{c} : {eval(c, globals().update(env))}\") \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\n\nMake the output more distinguishable between in and out of code block\n\ndef dbprint(src:str, # the source to debug in str\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            **env\n           ):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution 1: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\\\n    Caution 2: make sure to include all the necessary env variables to avoid \\\n    the same variable with different values from different scopes. Caution 3: when an env variable is updated, \\\n    then you need to includ it again in the next dbprint. Caution 4: be strict on the spaces, e.g., `for k, v in` \\\n    and `a = createsth(...)`\"\n    \n    # whether dbprint is working inside a for in loop or any kind of a loop\n    if defaults.block == True:\n        print('{:>157}'.format(\"===inside a block===\"))\n    else:\n        print('{:>157}'.format(\"===================================================\"))\n    \n    print(f\"\\n{src} <===== source code =======\") \n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        \n        # handle assignment\n        if \" = \" in c: # make sure assignment and !== and == are differentiated\n            \n            # print('k' in locals())\n            exec(c, globals().update(env)) \n            # print('k' in locals())\n            variable = c.partition(\" = \")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n            \n        # handle if statement\n        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must\n        elif \"if\" in c: \n            cond = re.search('if (.*?):', c).group(1)\n            \n            # when code in string is like 'if abc == def:'\n            if c.endswith(':'):\n                \n                # print ... \n                print(f\"{c} => {cond}: {eval(cond)}\")      \n                \n            # when code in string is like 'if abc == def: print(...)'\n            else: \n                # if the cond is true, then print ...\n                if eval(cond):\n                    \n                    # \"if abc == def: print(abc)\".split(': ', 2)[1] to get 'print(abc)'\n                    printc = c.split(': ', 1)[1]\n                    print(f\"{c} => {printc} : \")\n                    exec(c, globals().update(env))\n                    \n                # if cond is false, then print ...\n                else: \n                    print(f\"{c} => {cond}: {eval(cond)}\")\n                \n                \n        # handle for in statement\n        elif \"for \" in c and \" in \" in c: \n            \n            # if the code in string is like 'for k, v in abc:'\n            if c.endswith(':'):\n                \n                # get the substring between 'for ' and ' in', which is like 'k, v'\n                variables = re.search('for (.*?) in', c).group(1)\n                \n                # if variables has a substring like ', ' inside\n                if (', ') in variables: \n                    \n                    # split it by ', ' into a list of substrings\n                    vl = variables.split(', ')\n                    key = vl[0]\n                    value = vl[1]\n                    \n                    # make sure key and value will get evaluated first before exec run\n                    # printc is for exec to run\n                    printc = \"print(f'{key}:{eval(key)}, {type(eval(key))} ; {value}:{eval(value)}, {type(eval(value))}')\" \n                    # printmsg is for reader to understand with ease\n                    printmsg = \"print(f'key: {key}, {type(key)} ; value: {value}, {type(value)}')\"\n                    c1 = c + \" \" + printc\n                    print(f\"{c} => {printmsg} : \")          \n                    exec(c1, globals().update(env))\n                \n                else:\n                    printc = \"print(f'{variables} : {eval(variables)}')\"\n                    printmsg = \"print(f'i : {variables}')\"\n                    c1 = c + \" \" + printc\n                    print(f\"{c} => {printmsg} : \")          \n                    exec(c1, globals().update(env))\n                    \n            # if the code in string is like 'for k, v in abc: print(abc)'\n            else:                 \n                # \"for k, v in abc: print(k)\".split(': ', 1)[1] to get 'print(k)'\n                printc = c.split(': ', 1)[1]\n                print(f\"{c} => {printc} : \")\n                exec(c, globals().update(env))\n        \n        \n        # handle evaluation\n        else: \n            print(f\"{c} : {eval(c, globals().update(env))}\") \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\nsrc = \"this is a piece of code\"\n# 157\nendline = '{:>157}'.format(\"====================\")\n\nprint(endline)\n# print(f\"\\n{src} =====> {endline}\")\n\n                                                                                                                                         ====================\n\n\n\ntext = '{0:{fill}{align}155}'.format(\"a line of code\", fill='<', align='<')\nprint(text)\n\na line of code<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n\n\n\nadding features to handle a block of code execution\n\ndef dbprint(src:str, # the source to debug in str\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            **env\n           ):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution 1: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\\\n    Caution 2: make sure to include all the necessary env variables to avoid \\\n    the same variable with different values from different scopes. Caution 3: when an env variable is updated, \\\n    then you need to includ it again in the next dbprint. Caution 4: be strict on the spaces, e.g., `for k, v in` \\\n    and `a = createsth(...)`\"\n    \n    # whether dbprint is working inside a for in loop or any kind of a loop\n    if defaults.block == True:\n        print('{:>157}'.format(\"===inside a block===\"))\n    else:\n        print('{:>157}'.format(\"===================================================\"))\n    \n    # print out markers for a block of source and a line source code \n    if \"\\n\" in src: \n        print(src)\n        print('{:^157}'.format(\"================== a block of source codes =====================\"))\n    else:\n        print(src + \"<===== source code =======\") \n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        \n        # handle a block of code\n        if \"\\n\" in c: \n            block = ast.parse(c, mode='exec')\n            exec(compile(block, '<string>', mode='exec'), globals().update(env))\n        \n        # handle assignment\n        elif \" = \" in c: # make sure assignment and !== and == are differentiated\n            \n            # print('k' in locals())\n            exec(c, globals().update(env)) \n            # print('k' in locals())\n            variable = c.partition(\" = \")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n            \n        # handle if statement\n        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must\n        elif \"if\" in c: \n            cond = re.search('if (.*?):', c).group(1)\n            \n            # when code in string is like 'if abc == def:'\n            if c.endswith(':'):\n                \n                # print ... \n                print(f\"{c} => {cond}: {eval(cond)}\")      \n                \n            # when code in string is like 'if abc == def: print(...)'\n            else: \n                # if the cond is true, then print ...\n                if eval(cond):\n                    \n                    # \"if abc == def: print(abc)\".split(': ', 2)[1] to get 'print(abc)'\n                    printc = c.split(': ', 1)[1]\n                    print(f\"{c} => {printc} : \")\n                    exec(c, globals().update(env))\n                    \n                # if cond is false, then print ...\n                else: \n                    print(f\"{c} => {cond}: {eval(cond)}\")\n                \n                \n        # handle for in statement\n        elif \"for \" in c and \" in \" in c: \n            \n            # if the code in string is like 'for k, v in abc:'\n            if c.endswith(':'):\n                \n                # get the substring between 'for ' and ' in', which is like 'k, v'\n                variables = re.search('for (.*?) in', c).group(1)\n                \n                # if variables has a substring like ', ' inside\n                if (', ') in variables: \n                    \n                    # split it by ', ' into a list of substrings\n                    vl = variables.split(', ')\n                    key = vl[0]\n                    value = vl[1]\n                    \n                    # make sure key and value will get evaluated first before exec run\n                    # printc is for exec to run\n                    printc = \"print(f'{key}:{eval(key)}, {type(eval(key))} ; {value}:{eval(value)}, {type(eval(value))}')\" \n                    # printmsg is for reader to understand with ease\n                    printmsg = \"print(f'key: {key}, {type(key)} ; value: {value}, {type(value)}')\"\n                    c1 = c + \" \" + printc\n                    print(f\"{c} => {printmsg} : \")          \n                    exec(c1, globals().update(env))\n                \n                else:\n                    printc = \"print(f'{variables} : {eval(variables)}')\"\n                    printmsg = \"print(f'i : {variables}')\"\n                    c1 = c + \" \" + printc\n                    print(f\"{c} => {printmsg} : \")          \n                    exec(c1, globals().update(env))\n                    \n            # if the code in string is like 'for k, v in abc: print(abc)'\n            else:                 \n                # \"for k, v in abc: print(k)\".split(': ', 1)[1] to get 'print(k)'\n                printc = c.split(': ', 1)[1]\n                print(f\"{c} => {printc} : \")\n                exec(c, globals().update(env))\n        \n        \n        # handle evaluation\n        else: \n            print(f\"{c} : {eval(c, globals().update(env))}\") \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\nimport ast\nc =\"\"\"\na = 1\nb = 2\nc = a + b\n\"\"\"\nblock = ast.parse(c, mode='exec')\nexec(compile(block, '<string>', mode='exec'))\n\n\nb\n\n2\n\n\n\n\nadd feature to print out source code in both line and block to the right end of the page\n\ndef dbprint(src:str, # the source to debug in str\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            **env\n           ):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution 1: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\\\n    Caution 2: make sure to include all the necessary env variables to avoid \\\n    the same variable with different values from different scopes. Caution 3: when an env variable is updated, \\\n    then you need to includ it again in the next dbprint. Caution 4: be strict on the spaces, e.g., `for k, v in` \\\n    and `a = createsth(...)`\"\n    \n    # whether dbprint is working inside a for in loop or any kind of a loop\n    if defaults.block == True:\n        print('{:>157}'.format(\"===inside a block===\"))\n        print('{:>157}'.format(src))\n\n    else:\n        print('{:>157}'.format(\"===================================================\"))\n        print('{:>157}'.format(src))        \n    \n    # print out markers for a block of source and a line source code \n    if \"\\n\" in src: \n        # print(src)\n        # print('{:^157}'.format(\"================== a block of source codes =====================\"))\n        # print('{:>157}'.format(src))    \n        lst = src.split('\\n')\n        for l in lst: \n            print('{:>157}'.format(l))\n            \n    else:\n        print(src + \"<===== source code =======\") \n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        \n        # handle a block of code\n        if \"\\n\" in c: \n            block = ast.parse(c, mode='exec')\n            exec(compile(block, '<string>', mode='exec'), globals().update(env))\n        \n        # handle assignment\n        elif \" = \" in c: # make sure assignment and !== and == are differentiated\n            \n            # print('k' in locals())\n            exec(c, globals().update(env)) \n            # print('k' in locals())\n            variable = c.partition(\" = \")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n            \n        # handle if statement\n        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must\n        elif \"if\" in c: \n            cond = re.search('if (.*?):', c).group(1)\n            \n            # when code in string is like 'if abc == def:'\n            if c.endswith(':'):\n                \n                # print ... \n                print(f\"{c} => {cond}: {eval(cond)}\")      \n                \n            # when code in string is like 'if abc == def: print(...)'\n            else: \n                # if the cond is true, then print ...\n                if eval(cond):\n                    \n                    # \"if abc == def: print(abc)\".split(': ', 2)[1] to get 'print(abc)'\n                    printc = c.split(': ', 1)[1]\n                    print(f\"{c} => {printc} : \")\n                    exec(c, globals().update(env))\n                    \n                # if cond is false, then print ...\n                else: \n                    print(f\"{c} => {cond}: {eval(cond)}\")\n                \n                \n        # handle for in statement\n        elif \"for \" in c and \" in \" in c: \n            \n            # if the code in string is like 'for k, v in abc:'\n            if c.endswith(':'):\n                \n                # get the substring between 'for ' and ' in', which is like 'k, v'\n                variables = re.search('for (.*?) in', c).group(1)\n                \n                # if variables has a substring like ', ' inside\n                if (', ') in variables: \n                    \n                    # split it by ', ' into a list of substrings\n                    vl = variables.split(', ')\n                    key = vl[0]\n                    value = vl[1]\n                    \n                    # make sure key and value will get evaluated first before exec run\n                    # printc is for exec to run\n                    printc = \"print(f'{key}:{eval(key)}, {type(eval(key))} ; {value}:{eval(value)}, {type(eval(value))}')\" \n                    # printmsg is for reader to understand with ease\n                    printmsg = \"print(f'key: {key}, {type(key)} ; value: {value}, {type(value)}')\"\n                    c1 = c + \" \" + printc\n                    print(f\"{c} => {printmsg} : \")          \n                    exec(c1, globals().update(env))\n                \n                else:\n                    printc = \"print(f'{variables} : {eval(variables)}')\"\n                    printmsg = \"print(f'i : {variables}')\"\n                    c1 = c + \" \" + printc\n                    print(f\"{c} => {printmsg} : \")          \n                    exec(c1, globals().update(env))\n                    \n            # if the code in string is like 'for k, v in abc: print(abc)'\n            else:                 \n                # \"for k, v in abc: print(k)\".split(': ', 1)[1] to get 'print(k)'\n                printc = c.split(': ', 1)[1]\n                print(f\"{c} => {printc} : \")\n                exec(c, globals().update(env))\n        \n        \n        # handle evaluation\n        else: \n            print(f\"{c} : {eval(c, globals().update(env))}\") \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\nblocks = \"\"\"\nif to is None: \n    to_f,from_f = f.__base__.__init__,f.__init__\nelse:          \n    to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n        \"\"\"\nlst = blocks.split('\\n')\nfor l in lst: \n    print('{:>157}'.format(l))\n\n                                                                                                                                                             \n                                                                                                                                              if to is None: \n                                                                                                                 to_f,from_f = f.__base__.__init__,f.__init__\n                                                                                                                                              else:          \n                                                                                                   to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n                                                                                                                                                             \n\n\n\n\nadd feature: if abc from for k, v in abc: is empty, then skip the current iteration\n\ndef dbprint(src:str, # the source to debug in str\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            **env\n           ):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution 1: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\\\n    Caution 2: make sure to include all the necessary env variables to avoid \\\n    the same variable with different values from different scopes. Caution 3: when an env variable is updated, \\\n    then you need to includ it again in the next dbprint. Caution 4: be strict on the spaces, e.g., `for k, v in` \\\n    and `a = createsth(...)`\"\n    \n    # whether dbprint is working inside a for in loop or any kind of a loop\n    if defaults.block == True:\n        print('{:>157}'.format(\"===inside a block===\"))\n        print('{:>157}'.format(src))\n        print(src + \"<===== source code =======\") \n\n    else:\n        print('{:>157}'.format(\"===================================================\"))\n\n    \n        # print out markers for a block of source and a line source code \n        if \"\\n\" in src: \n            lst = src.split('\\n')\n            for l in lst: \n                print('{:>157}'.format(l))\n            print(src + \"<===== source code =======\") \n            print('{:^157}'.format(\"<===== source code =======\"))\n\n        else:\n            print('{:>157}'.format(src))        \n            print(src + \"<===== source code =======\") \n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        \n        # handle a block of code\n        if \"\\n\" in c: \n            block = ast.parse(c, mode='exec')\n            exec(compile(block, '<string>', mode='exec'), globals().update(env))\n        \n        # handle assignment\n        elif \" = \" in c: # make sure assignment and !== and == are differentiated\n            \n            # print('k' in locals())\n            exec(c, globals().update(env)) \n            # print('k' in locals())\n            variable = c.partition(\" = \")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n            \n        # handle if statement\n        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must\n        elif \"if\" in c: \n            cond = re.search('if (.*?):', c).group(1)\n            \n            # when code in string is like 'if abc == def:'\n            if c.endswith(':'):\n                \n                # print ... \n                print(f\"{c} => {cond}: {eval(cond)}\")      \n                \n            # when code in string is like 'if abc == def: print(...)'\n            else: \n                # if the cond is true, then print ...\n                if eval(cond):\n                    \n                    # \"if abc == def: print(abc)\".split(': ', 2)[1] to get 'print(abc)'\n                    printc = c.split(': ', 1)[1]\n                    print(f\"{c} => {printc} : \")\n                    exec(c, globals().update(env))\n                    \n                # if cond is false, then print ...\n                else: \n                    print(f\"{c} => {cond}: {eval(cond)}\")\n                \n                \n        # handle for in statement\n        elif \"for \" in c and \" in \" in c:           \n            \n            # in example like 'for k, v in abc:' or `for k, v in abc: print(...)`, if abc is empty\n            # step 1: access abc\n            # get the substring between 'in ' and ':', which is like 'abc'\n            abc = re.search('in (.*?):', c).group(1)\n            # if abc is empty dict or list: print and pass\n            if bool(abc): \n                print(f'{c} => {abc} is an emtpy {type(eval(abc))}')\n                continue \n                # The break statement can be used if you need to break out of a for or while loop and move onto the next section of code.\n                # The continue statement can be used if you need to skip the current iteration of a for or while loop and move onto the next iteration.\n            \n            # if the code in string is like 'for k, v in abc:', there is no more code after `:`\n            if c.endswith(':'):\n                \n                # get the substring between 'for ' and ' in', which is like 'k, v'\n                variables = re.search('for (.*?) in', c).group(1)\n                \n                # if variables has a substring like ', ' inside\n                if (', ') in variables: \n                    \n                    # split it by ', ' into a list of substrings\n                    vl = variables.split(', ')\n                    key = vl[0]\n                    value = vl[1]\n                    \n                    # make sure key and value will get evaluated first before exec run\n                    # printc is for exec to run\n                    printc = \"print(f'{key}:{eval(key)}, {type(eval(key))} ; {value}:{eval(value)}, {type(eval(value))}')\" \n                    # printmsg is for reader to understand with ease\n                    printmsg = \"print(f'key: {key}, {type(key)} ; value: {value}, {type(value)}')\"\n                    c1 = c + \" \" + printc\n                    print(f\"{c} => {printmsg} : \")          \n                    exec(c1, globals().update(env))\n                \n                else:\n                    printc = \"print(f'{variables} : {eval(variables)}')\"\n                    printmsg = \"print(f'i : {variables}')\"\n                    c1 = c + \" \" + printc\n                    print(f\"{c} => {printmsg} : \")          \n                    exec(c1, globals().update(env))\n                    \n            # if the code in string is like 'for k, v in abc: print(abc)'\n            else:                 \n                # \"for k, v in abc: print(k)\".split(': ', 1)[1] to get 'print(k)'\n                printc = c.split(': ', 1)[1]\n                print(f\"{c} => {printc} : \")\n                exec(c, globals().update(env)) # we can't use eval to run `for in` loop, but exec can.\n            ### Note: we shall not use the expression like `for k, v in abc print(abc)`\n            ### Note: we shall not use the expression like `for k, v in abc if k == def`\n        \n        \n        # handle evaluation\n        else: \n            print(f\"{c} : {eval(c, globals().update(env))}\") \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\ndict1 = {'a':1}\nlst1 = [1]\nbool(dict1)\n\nTrue\n\n\n\ndict1 = {}\nlst1 = []\nbool(dict1)\n\nFalse\n\n\n\n\nnicer output spacing\n\ndef dbprint(src:str, # the source to debug in str\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            **env\n           ):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution 1: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\\\n    Caution 2: make sure to include all the necessary env variables to avoid \\\n    the same variable with different values from different scopes. Caution 3: when an env variable is updated, \\\n    then you need to includ it again in the next dbprint. Caution 4: be strict on the spaces, e.g., `for k, v in` \\\n    and `a = createsth(...)`\"\n    \n    # whether dbprint is working inside a for in loop or any kind of a loop\n    if defaults.block == True:\n        print('\\n')\n        print('{:>157}'.format(\"===inside a block===\"))\n        print('{:>157}'.format(src))\n        print('\\n')\n        print(src + \"<===== source code =======\") \n\n    else:\n        print('\\n')\n        print('{:>157}'.format(\"===================================================\"))\n\n    \n        # print out markers for a block of source and a line source code \n        if \"\\n\" in src: \n            lst = src.split('\\n')\n            for l in lst: \n                print('{:>157}'.format(l))\n            print('\\n')\n\n            print('{:^157}'.format(\"<===== source code =======\"))\n            print(src) \n            print('\\n')\n\n        else:\n            print('{:>157}'.format(src))        \n            print(src + \"<===== source code =======\") \n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        print(\"\\n\")\n        \n        # handle a block of code\n        if \"\\n\" in c: \n            print(f\"{c} => \")\n            block = ast.parse(c, mode='exec')\n            exec(compile(block, '<string>', mode='exec'), globals().update(env))\n        \n        # handle assignment\n        elif \" = \" in c: # make sure assignment and !== and == are differentiated\n            \n            # print('k' in locals())\n            exec(c, globals().update(env)) \n            # print('k' in locals())\n            variable = c.partition(\" = \")[0]\n            print(f\"{c} => {variable}: {eval(variable)}\")\n            \n        # handle if statement\n        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must\n        elif \"if\" in c: \n            cond = re.search('if (.*?):', c).group(1)\n            \n            # when code in string is like 'if abc == def:'\n            if c.endswith(':'):\n                \n                # print ... \n                print(f\"{c} => {cond}: {eval(cond)}\")      \n                \n            # when code in string is like 'if abc == def: print(...)'\n            else: \n                # if the cond is true, then print ...\n                if eval(cond):\n                    \n                    # \"if abc == def: print(abc)\".split(': ', 2)[1] to get 'print(abc)'\n                    printc = c.split(': ', 1)[1]\n                    print(f\"{c} => {printc} : \")\n                    exec(c, globals().update(env))\n                    \n                # if cond is false, then print ...\n                else: \n                    print(f\"{c} => {cond}: {eval(cond)}\")\n                \n                \n        # handle for in statement\n        elif \"for \" in c and \" in \" in c:           \n            \n            # in example like 'for k, v in abc:' or `for k, v in abc: print(...)`, if abc is empty\n            # step 1: access abc\n            # get the substring between 'in ' and ':', which is like 'abc'\n            abc = re.search('in (.*?):', c).group(1)\n            # if abc is empty dict or list: print and pass\n            if bool(abc): \n                print(f'{c} => {abc} is an emtpy {type(eval(abc))}')\n                continue \n                # The break statement can be used if you need to break out of a for or while loop and move onto the next section of code.\n                # The continue statement can be used if you need to skip the current iteration of a for or while loop and move onto the next iteration.\n            \n            # if the code in string is like 'for k, v in abc:', there is no more code after `:`\n            if c.endswith(':'):\n                \n                # get the substring between 'for ' and ' in', which is like 'k, v'\n                variables = re.search('for (.*?) in', c).group(1)\n                \n                # if variables has a substring like ', ' inside\n                if (', ') in variables: \n                    \n                    # split it by ', ' into a list of substrings\n                    vl = variables.split(', ')\n                    key = vl[0]\n                    value = vl[1]\n                    \n                    # make sure key and value will get evaluated first before exec run\n                    # printc is for exec to run\n                    printc = \"print(f'{key}:{eval(key)}, {type(eval(key))} ; {value}:{eval(value)}, {type(eval(value))}')\" \n                    # printmsg is for reader to understand with ease\n                    printmsg = \"print(f'key: {key}, {type(key)} ; value: {value}, {type(value)}')\"\n                    c1 = c + \" \" + printc\n                    print(f\"{c} => {printmsg} : \")          \n                    exec(c1, globals().update(env))\n                \n                else:\n                    printc = \"print(f'{variables} : {eval(variables)}')\"\n                    printmsg = \"print(f'i : {variables}')\"\n                    c1 = c + \" \" + printc\n                    print(f\"{c} => {printmsg} : \")          \n                    exec(c1, globals().update(env))\n                    \n            # if the code in string is like 'for k, v in abc: print(abc)'\n            else:                 \n                # \"for k, v in abc: print(k)\".split(': ', 1)[1] to get 'print(k)'\n                printc = c.split(': ', 1)[1]\n                print(f\"{c} => {printc} : \")\n                exec(c, globals().update(env)) # we can't use eval to run `for in` loop, but exec can.\n            ### Note: we shall not use the expression like `for k, v in abc print(abc)`\n            ### Note: we shall not use the expression like `for k, v in abc if k == def`\n        \n        \n        # handle evaluation\n        else: \n            print(f\"{c} => {c} : {eval(c, globals().update(env))}\") \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\n\nprint output left and right reverted\n\ndef dbprint(src:str, # the source to debug in str\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            **env\n           ):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution 1: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\\\n    Caution 2: make sure to include all the necessary env variables to avoid \\\n    the same variable with different values from different scopes. Caution 3: when an env variable is updated, \\\n    then you need to includ it again in the next dbprint. Caution 4: be strict on the spaces, e.g., `for k, v in` \\\n    and `a = createsth(...)`\"\n    \n    # whether dbprint is working inside a for in loop or any kind of a loop\n    if defaults.block == True:\n        print('\\n')\n        print('{:>157}'.format(\"===source inside a block===\"))\n        print('{:>157}'.format(src))\n        print('\\n')\n        # print(src + \"<===== source code =======\") \n\n    else:\n        print('\\n')\n        # print('{:>157}'.format(\"======================== source code ===========================\"))\n        print('{:<157}'.format(\"============================= source code ================================\"))\n        print('{:<157}'.format(src))        \n    \n        # print out markers for a block of source and a line source code \n        # if \"\\n\" in src: \n        #     lst = src.split('\\n')\n        #     for l in lst: \n        #         print('{:>157}'.format(l))\n        #     print('\\n')\n\n            # print('{:^157}'.format(\"<===== source code =======\"))\n            # print(src)  # print the block of src for the second time but on the left hand side\n            # print('\\n')\n\n        # else:\n        #     print('{:>157}'.format(src))        \n            # print(src + \"<===== source code =======\") \n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        print(\"\\n\")\n        \n        # handle a block of code\n        if \"\\n\" in c: \n            output = f\"Running your code block => \"\n            print('{:<157}'.format(c))       \n            print('{:>157}'.format(output))  \n            print('The code block printout => : ')\n            block = ast.parse(c, mode='exec')\n            exec(compile(block, '<string>', mode='exec'), globals().update(env))\n        \n        # handle assignment\n        elif \" = \" in c: # make sure assignment and !== and == are differentiated\n            \n            # print('k' in locals())\n            exec(c, globals().update(env)) \n            # print('k' in locals())\n            variable = c.partition(\" = \")[0]\n            # print(f\"{c} => {variable}: {eval(variable)}\")\n            output = f\"{c} => {variable}: {eval(variable)}\"\n            print('{:>157}'.format(output))       \n            \n        # handle if statement\n        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must\n        elif \"if\" in c: \n            cond = re.search('if (.*?):', c).group(1)\n            \n            # when code in string is like 'if abc == def:'\n            if c.endswith(':'):\n                \n                # print ... \n                # print(f\"{c} => {cond}: {eval(cond)}\")      \n                output = f\"{c} => {cond}: {eval(cond)}\"\n                print('{:>157}'.format(output))\n                \n            # when code in string is like 'if abc == def: print(...)'\n            else: \n                # if the cond is true, then print ...\n                if eval(cond):\n                    \n                    # \"if abc == def: print(abc)\".split(': ', 2)[1] to get 'print(abc)'\n                    printc = c.split(': ', 1)[1]\n                    # print(f\"{c} => {printc} : \")\n                    output = f\"{c} => {printc} : \"\n                    print('{:>157}'.format(output))      \n                    exec(c, globals().update(env))\n                    \n                # if cond is false, then print ...\n                else: \n                    # print(f\"{c} => {cond}: {eval(cond)}\")\n                    output = f\"{c} => {cond}: {eval(cond)}\"\n                    print('{:>157}'.format(output))   \n                \n                \n        # handle for in statement\n        elif \"for \" in c and \" in \" in c:           \n            \n            # in example like 'for k, v in abc:' or `for k, v in abc: print(...)`, if abc is empty\n            # step 1: access abc\n            # get the substring between 'in ' and ':', which is like 'abc'\n            abc = re.search('in (.*?):', c).group(1)\n            # if abc is empty dict or list: print and pass\n            if bool(abc): \n                # print(f'{c} => {abc} is an emtpy {type(eval(abc))}')\n                output = f'{c} => {abc} is an emtpy {type(eval(abc))}'\n                print('{:>157}'.format(output))   \n                continue \n                # The break statement can be used if you need to break out of a for or while loop and move onto the next section of code.\n                # The continue statement can be used if you need to skip the current iteration of a for or while loop and move onto the next iteration.\n            \n            # if the code in string is like 'for k, v in abc:', there is no more code after `:`\n            if c.endswith(':'):\n                \n                # get the substring between 'for ' and ' in', which is like 'k, v'\n                variables = re.search('for (.*?) in', c).group(1)\n                \n                # if variables has a substring like ', ' inside\n                if (', ') in variables: \n                    \n                    # split it by ', ' into a list of substrings\n                    vl = variables.split(', ')\n                    key = vl[0]\n                    value = vl[1]\n                    \n                    # make sure key and value will get evaluated first before exec run\n                    # printc is for exec to run\n                    printc = \"print(f'{key}:{eval(key)}, {type(eval(key))} ; {value}:{eval(value)}, {type(eval(value))}')\" \n                    # printmsg is for reader to understand with ease\n                    printmsg = \"print(f'key: {key}, {type(key)} ; value: {value}, {type(value)}')\"\n                    c1 = c + \" \" + printc\n                    # print(f\"{c} => {printmsg} : \")      \n                    output = f\"{c} => {printmsg} : \"\n                    print('{:>157}'.format(output))   \n                    exec(c1, globals().update(env))\n                \n                else:\n                    printc = \"print(f'{variables} : {eval(variables)}')\"\n                    printmsg = \"print(f'i : {variables}')\"\n                    c1 = c + \" \" + printc\n                    # print(f\"{c} => {printmsg} : \")     \n                    output = f\"{c} => {printmsg} : \"\n                    print('{:>157}'.format(output))   \n                    exec(c1, globals().update(env))\n                    \n            # if the code in string is like 'for k, v in abc: print(abc)'\n            else:                 \n                # \"for k, v in abc: print(k)\".split(': ', 1)[1] to get 'print(k)'\n                printc = c.split(': ', 1)[1]\n                # print(f\"{c} => {printc} : \")\n                output = f\"{c} => {printc} : \"\n                print('{:>157}'.format(output))   \n                exec(c, globals().update(env)) # we can't use eval to run `for in` loop, but exec can.\n            ### Note: we shall not use the expression like `for k, v in abc print(abc)`\n            ### Note: we shall not use the expression like `for k, v in abc if k == def`\n        \n        \n        # handle evaluation\n        else: \n            # print(f\"{c} => {c} : {eval(c, globals().update(env))}\") \n            output = f\"{c} => {c} : {eval(c, globals().update(env))}\"\n            print('{:>157}'.format(output))   \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\n\nadd feature: print out the entire source code and use ====== to mark the source code line at debugging\n\nimport inspect\nimport fastcore.meta as fm\ndefaults.src = inspect.getsource(fm.delegates)\n\n\ndefaults.src\n\n'def delegates(to:FunctionType=None, # Delegatee\\n              keep=False, # Keep `kwargs` in decorated function?\\n              but:list=None): # Exclude these parameters from signature\\n    \"Decorator: replace `**kwargs` in signature with params from `to`\"\\n    if but is None: but = []\\n    def _f(f):\\n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\\n        from_f = getattr(from_f,\\'__func__\\',from_f)\\n        to_f = getattr(to_f,\\'__func__\\',to_f)\\n        if hasattr(from_f,\\'__delwrap__\\'): return f\\n        sig = inspect.signature(from_f)\\n        sigd = dict(sig.parameters)\\n        k = sigd.pop(\\'kwargs\\')\\n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()\\n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}\\n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}\\n        sigd.update(s2)\\n        if keep: sigd[\\'kwargs\\'] = k\\n        else: from_f.__delwrap__ = to_f\\n        from_f.__signature__ = sig.replace(parameters=sigd.values())\\n        if hasattr(from_f, \\'__annotations__\\'): from_f.__annotations__.update(anno)\\n        return f\\n    return _f\\n'\n\n\n\nlst = defaults.src.split('\\n')\nl1 = lst[6]\nl1\n\n'        if to is None: to_f,from_f = f.__base__.__init__,f.__init__'\n\n\n\nl1.strip()\nl1\n\n'        if to is None: to_f,from_f = f.__base__.__init__,f.__init__'\n\n\n\nblock1 = \"\"\"\nif to is None: to_f,from_f = f.__base__.__init__,f.__init__\nelse:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n        \"\"\"\nblock1\n\n'\\nif to is None: to_f,from_f = f.__base__.__init__,f.__init__\\nelse:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\\n        '\n\n\n\nlst[6].strip() in block1\n\nTrue\n\n\n\nlst[-1], lst[-4]\n\n('',\n \"        if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)\")\n\n\n\nbool(lst[-2])\n\nTrue\n\n\n\n\ndefaults.block is no longer needed I think\n\nclass dbcolors:\n    g = '\\033[92m' #GREEN\n    y = '\\033[93m' #YELLOW\n    r = '\\033[91m' #RED\n    reset = '\\033[0m' #RESET COLOR\n\n\ndef colorize(): pass\n\n\ndef dbprint(src:str, # the source to debug in str\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            **env\n           ):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution 1: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\\\n    Caution 2: make sure to include all the necessary env variables to avoid \\\n    the same variable with different values from different scopes. Caution 3: when an env variable is updated, \\\n    then you need to includ it again in the next dbprint. Caution 4: be strict on the spaces, e.g., `for k,v in` \\\n    and `a = createsth(...)`\"\n    \n    # whether dbprint is working inside a for in loop or any kind of a loop\n    if defaults.block == True:\n        print('\\n')\n        print('{:>157}'.format(\"===source inside a block===\"))\n        print('{:>157}'.format(src))\n        print('\\n')\n        # print(src + \"<===== source code =======\") \n\n    else:\n        print('\\n')\n        # print('{:>157}'.format(\"======================== source code ===========================\"))\n        print('{:<157}'.format(\"============================= source code ================================\"))\n        print('{:<157}'.format(src))        \n        \n        # print the source code of the function\n        lst = defaults.src.split('\\n')\n        for l in lst: \n            if bool(l) and l.strip() in src: # how to make sure all these ls are close to each other???\n                print('{:=<157}'.format(l))\n            else: \n                print('{:<157}'.format(l))\n        print('\\n')\n        \n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        print(\"\\n\")\n        \n        # handle a block of code\n        if \"\\n\" in c: \n            output = f\"Running your code block => \"\n            print('{:<157}'.format(c))       \n            print('{:>157}'.format(output))  \n            print('The code block printout => : ')\n            block = ast.parse(c, mode='exec')\n            exec(compile(block, '<string>', mode='exec'), globals().update(env))\n        \n        # handle assignment\n        elif \" = \" in c: # make sure assignment and !== and == are differentiated\n            \n            # print('k' in locals())\n            exec(c, globals().update(env)) \n            # print('k' in locals())\n            variable = c.partition(\" = \")[0]\n            # print(f\"{c} => {variable}: {eval(variable)}\")\n            output = f\"{c} => {variable}: {eval(variable)}\"\n            print('{:>157}'.format(output))       \n            \n        # handle if statement\n        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must\n        elif \"if\" in c: \n            cond = re.search('if (.*?):', c).group(1)\n            \n            # when code in string is like 'if abc == def:'\n            if c.endswith(':'):\n                \n                # print ... \n                # print(f\"{c} => {cond}: {eval(cond)}\")      \n                output = f\"{c} => {cond}: {eval(cond)}\"\n                print('{:>157}'.format(output))\n                \n            # when code in string is like 'if abc == def: print(...)'\n            else: \n                # if the cond is true, then print ...\n                if eval(cond):\n                    \n                    # \"if abc == def: print(abc)\".split(': ', 2)[1] to get 'print(abc)'\n                    printc = c.split(': ', 1)[1]\n                    # print(f\"{c} => {printc} : \")\n                    output = f\"{c} => {printc} : \"\n                    print('{:>157}'.format(output))      \n                    exec(c, globals().update(env))\n                    \n                # if cond is false, then print ...\n                else: \n                    # print(f\"{c} => {cond}: {eval(cond)}\")\n                    output = f\"{c} => {cond}: {eval(cond)}\"\n                    print('{:>157}'.format(output))   \n                \n                \n        # handle for in statement\n        elif \"for \" in c and \" in \" in c:           \n            \n            # in example like 'for k, v in abc:' or `for k, v in abc: print(...)`, if abc is empty\n            # step 1: access abc\n            # get the substring between 'in ' and ':', which is like 'abc'\n            abc = re.search('in (.*?):', c).group(1)\n            # if abc is empty dict or list: print and pass\n            if not bool(eval(abc)): \n                # print(f'{c} => {abc} is an emtpy {type(eval(abc))}')\n                output = f'{c} => {abc} is an emtpy {type(eval(abc))}'\n                print('{:>157}'.format(output))   \n                continue \n                # The break statement can be used if you need to break out of a for or while loop and move onto the next section of code.\n                # The continue statement can be used if you need to skip the current iteration of a for or while loop and move onto the next iteration.\n            \n            # if the code in string is like 'for k, v in abc:', there is no more code after `:`\n            if c.endswith(':'):\n                \n                # get the substring between 'for ' and ' in', which is like 'k, v'\n                variables = re.search('for (.*?) in', c).group(1)\n                \n                # if variables has a substring like ', ' inside\n                if (',') in variables: \n                    \n                    # split it by ', ' into a list of substrings\n                    vl = variables.split(',')\n                    key = vl[0]\n                    value = vl[1]\n                    \n                    # make sure key and value will get evaluated first before exec run\n                    # printc is for exec to run\n                    printc = \"print(f'{key}:{eval(key)}, {type(eval(key))} ; {value}:{eval(value)}, {type(eval(value))}')\" \n                    # printmsg is for reader to understand with ease\n                    printmsg = \"print(f'key: {key}, {type(key)} ; value: {value}, {type(value)}')\"\n                    c1 = c + \" \" + printc\n                    # print(f\"{c} => {printmsg} : \")      \n                    output = f\"{c} => {printmsg} : \"\n                    print('{:>157}'.format(output))   \n                    exec(c1, globals().update(env))\n                \n                else:\n                    printc = \"print(f'{variables} : {eval(variables)}')\"\n                    printmsg = \"print(f'i : {variables}')\"\n                    c1 = c + \" \" + printc\n                    # print(f\"{c} => {printmsg} : \")     \n                    output = f\"{c} => {printmsg} : \"\n                    print('{:>157}'.format(output))   \n                    exec(c1, globals().update(env))\n                    \n            # if the code in string is like 'for k, v in abc: print(abc)'\n            else:                 \n                # \"for k, v in abc: print(k)\".split(': ', 1)[1] to get 'print(k)'\n                printc = c.split(': ', 1)[1]\n                # print(f\"{c} => {printc} : \")\n                output = f\"{c} => {printc} : \"\n                print('{:>157}'.format(output))   \n                exec(c, globals().update(env)) # we can't use eval to run `for in` loop, but exec can.\n            ### Note: we shall not use the expression like `for k, v in abc print(abc)`\n            ### Note: we shall not use the expression like `for k, v in abc if k == def`\n        \n        \n        # handle evaluation\n        else: \n            # print(f\"{c} => {c} : {eval(c, globals().update(env))}\") \n            output = f\"{c} => {c} : {eval(c, globals().update(env))}\"\n            print('{:>157}'.format(output))   \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\n\nadd features to colorize question, feature and comment\n\ndef dbprint(src:str, # the source to debug in str\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            **env\n           ):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution 1: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\\\n    Caution 2: make sure to include all the necessary env variables to avoid \\\n    the same variable with different values from different scopes. Caution 3: when an env variable is updated, \\\n    then you need to includ it again in the next dbprint. Caution 4: be strict on the spaces, e.g., `for k,v in` \\\n    and `a = createsth(...)`\"\n    \n    # whether dbprint is working inside a for in loop or any kind of a loop\n    if defaults.block == True:\n        print('\\n')\n        print('{:>157}'.format(\"===source inside a block===\"))\n        print('{:>157}'.format(src))\n        print('\\n')\n        # print(src + \"<===== source code =======\") \n\n    else:\n        print('\\n')\n        # print('{:>157}'.format(\"======================== source code ===========================\"))\n        print('{:<157}'.format(\"============================= source code ================================\"))\n        print('{:<157}'.format(src))        \n        \n        # print the source code of the function\n        lst = defaults.src.split('\\n')\n        for l in lst: \n            if bool(l) and l.strip() in src: # how to make sure all these ls are close to each other???\n                print('{:=<157}'.format(l))\n            else: \n                print('{:<157}'.format(l))\n        # print out the example\n        print('{:<157}'.format(defaults.eg))\n        \n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        print(\"\\n\")\n        \n        c1 = None # use it as container for colored string\n        # handle comment\n        if \"#comment#\" in c:\n            _,c1 = colorize(c)\n            # print('{:>157}'.format(c1))   \n            print(c1)\n            continue\n        else:\n\n            # c is normal string, c1 is colored string, both are without #question# or #feature# or #comment#\n            c,c1 = colorize(c)\n        \n        # handle a block of code\n        if \"\\n\" in c: \n            output = f\"Running your code block => \"\n            print('{:<157}'.format(c))       \n            print('{:>157}'.format(output))  \n            print('The code block printout => : ')\n            block = ast.parse(c, mode='exec')\n            exec(compile(block, '<string>', mode='exec'), globals().update(env))\n        \n        # handle assignment\n        elif \" = \" in c: # make sure assignment and !== and == are differentiated\n            exec(c, globals().update(env)) \n            variable = c.partition(\" = \")[0]\n            output = f\"{c1} => {variable}: {eval(variable)}\"\n            print('{:>157}'.format(output))       \n            \n        # handle if statement\n        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must\n        elif \"if\" in c: \n            cond = re.search('if (.*?):', c).group(1)\n            \n            # when code in string is like 'if abc == def:'\n            if c.endswith(':'):\n                \n                # print ... \n                # print(f\"{c} => {cond}: {eval(cond)}\")      \n                output = f\"{c} => {cond}: {eval(cond)}\"\n                print('{:>157}'.format(output))\n                \n            # when code in string is like 'if abc == def: print(...)'\n            else: \n                # if the cond is true, then print ...\n                if eval(cond):\n                    \n                    # \"if abc == def: print(abc)\".split(': ', 2)[1] to get 'print(abc)'\n                    printc = c.split(': ', 1)[1]\n                    # print(f\"{c} => {printc} : \")\n                    output = f\"{c} => {printc} : \"\n                    print('{:>157}'.format(output))      \n                    exec(c, globals().update(env))\n                    \n                # if cond is false, then print ...\n                else: \n                    # print(f\"{c} => {cond}: {eval(cond)}\")\n                    output = f\"{c} => {cond}: {eval(cond)}\"\n                    print('{:>157}'.format(output))   \n                \n                \n        # handle for in statement\n        elif \"for \" in c and \" in \" in c:           \n            \n            # in example like 'for k, v in abc:' or `for k, v in abc: print(...)`, if abc is empty\n            # step 1: access abc\n            # get the substring between 'in ' and ':', which is like 'abc'\n            abc = re.search('in (.*?):', c).group(1)\n            # if abc is empty dict or list: print and pass\n            if not bool(eval(abc)): \n                # print(f'{c} => {abc} is an emtpy {type(eval(abc))}')\n                output = f'{c} => {abc} is an emtpy {type(eval(abc))}'\n                print('{:>157}'.format(output))   \n                 \n                # The break statement can be used if you need to break out of a for or while loop and move onto the next section of code.\n                # The continue statement can be used if you need to skip the current iteration of a for or while loop and move onto the next iteration.\n            \n            # if the code in string is like 'for k, v in abc:', there is no more code after `:`\n            if c.endswith(':'):\n                \n                # get the substring between 'for ' and ' in', which is like 'k, v'\n                variables = re.search('for (.*?) in', c).group(1)\n                \n                # if variables has a substring like ', ' inside\n                if (',') in variables: \n                    \n                    # split it by ', ' into a list of substrings\n                    vl = variables.split(',')\n                    key = vl[0]\n                    value = vl[1]\n                    \n                    # make sure key and value will get evaluated first before exec run\n                    # printc is for exec to run\n                    printc = \"print(f'{key}:{eval(key)}, {type(eval(key))} ; {value}:{eval(value)}, {type(eval(value))}')\" \n                    # printmsg is for reader to understand with ease\n                    printmsg = \"print(f'key: {key}, {type(key)} ; value: {value}, {type(value)}')\"\n                    c1 = c + \" \" + printc\n                    # print(f\"{c} => {printmsg} : \")      \n                    output = f\"{c} => {printmsg} : \"\n                    print('{:>157}'.format(output))   \n                    exec(c1, globals().update(env))\n                \n                else:\n                    printc = \"print(f'{variables} : {eval(variables)}')\"\n                    printmsg = \"print(f'i : {variables}')\"\n                    c1 = c + \" \" + printc\n                    # print(f\"{c} => {printmsg} : \")     \n                    output = f\"{c} => {printmsg} : \"\n                    print('{:>157}'.format(output))   \n                    exec(c1, globals().update(env))\n                    \n            # if the code in string is like 'for k, v in abc: print(abc)'\n            else:                 \n                # \"for k, v in abc: print(k)\".split(': ', 1)[1] to get 'print(k)'\n                printc = c.split(': ', 1)[1]\n                output = f\"{c} => {printc} : \"\n                print('{:>157}'.format(output))   \n                exec(c, globals().update(env)) # we can't use eval to run `for in` loop, but exec can.\n            ### Note: we shall not use the expression like `for k, v in abc print(abc)`\n            ### Note: we shall not use the expression like `for k, v in abc if k == def`\n        \n        # handle comment\n        # elif \"#comment#\" in c:\n        #     # c,c1 = colorize(c)\n        #     print('{:>157}'.format(c1))   \n        #     print(c1)\n        \n        # handle evaluation\n        else: \n            # c1 is to color #feature# or #question#\n            # c,c1 = colorize(c)\n            output = f\"{c} => {c1} : {eval(c, globals().update(env))}\"\n            print('{:>157}'.format(output))   \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\nblocks = \"\"\"\nif to is None: \n    to_f,from_f = f.__base__.__init__,f.__init__\nelse:          \n    to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n        \"\"\"\nlst = blocks.split('\\n')\nfor l in lst: \n    print('{:>157}'.format(l))\n\n                                                                                                                                                             \n                                                                                                                                              if to is None: \n                                                                                                                 to_f,from_f = f.__base__.__init__,f.__init__\n                                                                                                                                              else:          \n                                                                                                   to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n                                                                                                                                                             \n\n\n\nblocks = \"\"\"\nif to is None:\n    to_f,from_f = f.__base__.__init__,f.__init__\nelse:\n    to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n        \"\"\"\n\n\n\n\nalignright\n\n alignright (blocks)\n\n\nalignright(\"this is me\")\nalignright('\\x1b[91mthis is me\\x1b[0m') # can we align this colored line all the way to the right?\n\n                                                                                                                                                   this is me\n                                                                                                                                          this is me\n\n\n\ndef dbprint(src:str, # the source to debug in str\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            cmt:str=None, # add colorful comment\n            **env\n           ):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution 1: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\\\n    Caution 2: make sure to include all the necessary env variables to avoid \\\n    the same variable with different values from different scopes. Caution 3: when an env variable is updated, \\\n    then you need to includ it again in the next dbprint. Caution 4: be strict on the spaces, e.g., `for k,v in` \\\n    and `a = createsth(...)`\"\n    \n    # whether dbprint is working inside a for in loop or any kind of a loop\n    if defaults.block == True:\n        print('\\n')\n        print('{:>157}'.format(\"===source inside a block===\"))\n        print('{:>157}'.format(src))\n        print('\\n')\n        # print(src + \"<===== source code =======\") \n\n    else:\n        print('\\n')\n        # print('{:>157}'.format(\"======================== source code ===========================\"))\n        print('{:<157}'.format(\"============================= source code ================================\"))\n        print('{:<157}'.format(src))        \n        \n        # print the source code of the function\n        lst = defaults.src.split('\\n')\n        for l in lst: \n            if bool(l) and l.strip() in src: # how to make sure all these ls are close to each other???\n                print('{:=<157}'.format(l))\n            else: \n                print('{:<157}'.format(l))\n        # print out the example\n        print('{:<157}'.format(defaults.eg))\n        \n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        print(\"\\n\")\n        \n#         c1 = None # use it as container for colored string\n#         # handle comment\n#         if \"#comment#\" in c:\n#             _,c1 = colorize(c)\n#             # print('{:>157}'.format(c1))   \n#             print(c1)\n#             continue\n#         else:\n\n#             # c is normal string, c1 is colored string, both are without #question# or #feature# or #comment#\n#             c,c1 = colorize(c)\n        \n        # handle a block of code\n        if \"\\n\" in c: \n            output = f\"Running your code block => \"\n            print('{:<157}'.format(c))       \n            print('{:>157}'.format(output))  \n            print('The code block printout => : ')\n            block = ast.parse(c, mode='exec')\n            exec(compile(block, '<string>', mode='exec'), globals().update(env))\n        \n        # handle assignment\n        elif \" = \" in c: # make sure assignment and !== and == are differentiated\n            exec(c, globals().update(env)) \n            variable = c.partition(\" = \")[0]\n            output = f\"{c1} => {variable}: {eval(variable)}\"\n            print('{:>157}'.format(output))       \n            \n        # handle if statement\n        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must\n        elif \"if\" in c: \n            cond = re.search('if (.*?):', c).group(1)\n            \n            # when code in string is like 'if abc == def:'\n            if c.endswith(':'):\n                \n                # print ... \n                # print(f\"{c} => {cond}: {eval(cond)}\")      \n                output = f\"{c} => {cond}: {eval(cond)}\"\n                print('{:>157}'.format(output))\n                \n            # when code in string is like 'if abc == def: print(...)'\n            else: \n                # if the cond is true, then print ...\n                if eval(cond):\n                    \n                    # \"if abc == def: print(abc)\".split(': ', 2)[1] to get 'print(abc)'\n                    printc = c.split(': ', 1)[1]\n                    # print(f\"{c} => {printc} : \")\n                    output = f\"{c} => {printc} : \"\n                    print('{:>157}'.format(output))      \n                    exec(c, globals().update(env))\n                    \n                # if cond is false, then print ...\n                else: \n                    # print(f\"{c} => {cond}: {eval(cond)}\")\n                    output = f\"{c} => {cond}: {eval(cond)}\"\n                    print('{:>157}'.format(output))   \n                \n                \n        # handle for in statement\n        elif \"for \" in c and \" in \" in c:           \n            \n            # in example like 'for k, v in abc:' or `for k, v in abc: print(...)`, if abc is empty\n            # step 1: access abc\n            # get the substring between 'in ' and ':', which is like 'abc'\n            abc = re.search('in (.*?):', c).group(1)\n            # if abc is empty dict or list: print and pass\n            if not bool(eval(abc)): \n                # print(f'{c} => {abc} is an emtpy {type(eval(abc))}')\n                output = f'{c} => {abc} is an emtpy {type(eval(abc))}'\n                print('{:>157}'.format(output))   \n                 \n                # The break statement can be used if you need to break out of a for or while loop and move onto the next section of code.\n                # The continue statement can be used if you need to skip the current iteration of a for or while loop and move onto the next iteration.\n            \n            # if the code in string is like 'for k, v in abc:', there is no more code after `:`\n            if c.endswith(':'):\n                \n                # get the substring between 'for ' and ' in', which is like 'k, v'\n                variables = re.search('for (.*?) in', c).group(1)\n                \n                # if variables has a substring like ', ' inside\n                if (',') in variables: \n                    \n                    # split it by ', ' into a list of substrings\n                    vl = variables.split(',')\n                    key = vl[0]\n                    value = vl[1]\n                    \n                    # make sure key and value will get evaluated first before exec run\n                    # printc is for exec to run\n                    printc = \"print(f'{key}:{eval(key)}, {type(eval(key))} ; {value}:{eval(value)}, {type(eval(value))}')\" \n                    # printmsg is for reader to understand with ease\n                    printmsg = \"print(f'key: {key}, {type(key)} ; value: {value}, {type(value)}')\"\n                    c1 = c + \" \" + printc\n                    # print(f\"{c} => {printmsg} : \")      \n                    output = f\"{c} => {printmsg} : \"\n                    print('{:>157}'.format(output))   \n                    exec(c1, globals().update(env))\n                \n                else:\n                    printc = \"print(f'{variables} : {eval(variables)}')\"\n                    printmsg = \"print(f'i : {variables}')\"\n                    c1 = c + \" \" + printc\n                    # print(f\"{c} => {printmsg} : \")     \n                    output = f\"{c} => {printmsg} : \"\n                    print('{:>157}'.format(output))   \n                    exec(c1, globals().update(env))\n                    \n            # if the code in string is like 'for k, v in abc: print(abc)'\n            else:                 \n                # \"for k, v in abc: print(k)\".split(': ', 1)[1] to get 'print(k)'\n                printc = c.split(': ', 1)[1]\n                output = f\"{c} => {printc} : \"\n                print('{:>157}'.format(output))   \n                exec(c, globals().update(env)) # we can't use eval to run `for in` loop, but exec can.\n            ### Note: we shall not use the expression like `for k, v in abc print(abc)`\n            ### Note: we shall not use the expression like `for k, v in abc if k == def`\n        \n        # handle comment\n        # elif \"#comment#\" in c:\n        #     # c,c1 = colorize(c)\n        #     print('{:>157}'.format(c1))   \n        #     print(c1)\n        \n        # handle evaluation\n        else: \n            # c1 is to color #feature# or #question#\n            # c,c1 = colorize(c)\n            output = f\"{c} => {c1} : {eval(c, globals().update(env))}\"\n            print('{:>157}'.format(output))   \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\nclst = \"this is me\".split('\\n') \nlen(clst)\n\n1\n\n\n\n\n\ndbcolors\n\n dbcolors ()\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\ncolorize\n\n colorize (cmt, color:str=None)\n\n\nprint(colorize(\"this is me\", \"r\") + colorize(\"this is me\", \"y\"))\n\nthis is methis is me\n\n\n\ndef dbprint(src:str, # the source to debug in str\n            cmt:str,\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            **env\n           ):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution 1: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\\\n    Caution 2: make sure to include all the necessary env variables to avoid \\\n    the same variable with different values from different scopes. Caution 3: when an env variable is updated, \\\n    then you need to includ it again in the next dbprint. Caution 4: be strict on the spaces, e.g., `for k,v in` \\\n    and `a = createsth(...)`\"\n    \n    # whether dbprint is working inside a for in loop or any kind of a loop\n    if defaults.block == True:\n        print('\\n')\n        print('{:>157}'.format(\"===source inside a block===\"))\n        print('{:>157}'.format(src))\n        print('\\n')\n        # print(src + \"<===== source code =======\") \n\n    else:\n        print('\\n')\n        # print('{:>157}'.format(\"======================== source code ===========================\"))\n        print('{:<157}'.format(\"============================= source code ================================\"))\n        print('{:<157}'.format(src))        \n        \n        # print the source code of the function\n        lst = defaults.src.split('\\n')\n\n        ccount = 0\n        for l in lst: \n            if bool(l) and l.strip() in src: # how to make sure all these ls are close to each other???\n                print('{:=<157}'.format(l))\n                \n                if bool(cmt):\n                    clst = cmt.split('\\n') \n                    if ccount <= len(clst)-1:\n                        print('{:>157}'.format(colorize(clst[ccount])))\n                        ccount = ccount + 1\n\n            else: \n                print('{:<157}'.format(l))\n\n        # print out the example\n        print('{:<157}'.format(defaults.eg))\n        \n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        print(\"\\n\")\n        \n        # handle a block of code\n        if \"\\n\" in c: \n            output = f\"Running your code block => \"\n            print('{:<157}'.format(c))       \n            print('{:>157}'.format(output))  \n            print('The code block printout => : ')\n            block = ast.parse(c, mode='exec')\n            exec(compile(block, '<string>', mode='exec'), globals().update(env))\n        \n        # handle assignment\n        elif \" = \" in c: # make sure assignment and !== and == are differentiated\n            \n            # print('k' in locals())\n            exec(c, globals().update(env)) \n            # print('k' in locals())\n            variable = c.partition(\" = \")[0]\n            # print(f\"{c} => {variable}: {eval(variable)}\")\n            output = f\"{c} => {variable}: {eval(variable)}\"\n            print('{:>157}'.format(output))       \n            \n        # handle if statement\n        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must\n        elif \"if\" in c: \n            cond = re.search('if (.*?):', c).group(1)\n            \n            # when code in string is like 'if abc == def:'\n            if c.endswith(':'):\n                \n                # print ... \n                # print(f\"{c} => {cond}: {eval(cond)}\")      \n                output = f\"{c} => {cond}: {eval(cond)}\"\n                print('{:>157}'.format(output))\n                \n            # when code in string is like 'if abc == def: print(...)'\n            else: \n                # if the cond is true, then print ...\n                if eval(cond):\n                    \n                    # \"if abc == def: print(abc)\".split(': ', 2)[1] to get 'print(abc)'\n                    printc = c.split(': ', 1)[1]\n                    # print(f\"{c} => {printc} : \")\n                    output = f\"{c} => {printc} : \"\n                    print('{:>157}'.format(output))      \n                    exec(c, globals().update(env))\n                    \n                # if cond is false, then print ...\n                else: \n                    # print(f\"{c} => {cond}: {eval(cond)}\")\n                    output = f\"{c} => {cond}: {eval(cond)}\"\n                    print('{:>157}'.format(output))   \n                \n                \n        # handle for in statement\n        elif \"for \" in c and \" in \" in c:           \n            \n            # in example like 'for k, v in abc:' or `for k, v in abc: print(...)`, if abc is empty\n            # step 1: access abc\n            # get the substring between 'in ' and ':', which is like 'abc'\n            abc = re.search('in (.*?):', c).group(1)\n            # if abc is empty dict or list: print and pass\n            if not bool(eval(abc)): \n                # print(f'{c} => {abc} is an emtpy {type(eval(abc))}')\n                output = f'{c} => {abc} is an emtpy {type(eval(abc))}'\n                print('{:>157}'.format(output))   \n                continue \n                # The break statement can be used if you need to break out of a for or while loop and move onto the next section of code.\n                # The continue statement can be used if you need to skip the current iteration of a for or while loop and move onto the next iteration.\n            \n            # if the code in string is like 'for k, v in abc:', there is no more code after `:`\n            if c.endswith(':'):\n                \n                # get the substring between 'for ' and ' in', which is like 'k, v'\n                variables = re.search('for (.*?) in', c).group(1)\n                \n                # if variables has a substring like ', ' inside\n                if (',') in variables: \n                    \n                    # split it by ', ' into a list of substrings\n                    vl = variables.split(',')\n                    key = vl[0]\n                    value = vl[1]\n                    \n                    # make sure key and value will get evaluated first before exec run\n                    # printc is for exec to run\n                    printc = \"print(f'{key}:{eval(key)}, {type(eval(key))} ; {value}:{eval(value)}, {type(eval(value))}')\" \n                    # printmsg is for reader to understand with ease\n                    printmsg = \"print(f'key: {key}, {type(key)} ; value: {value}, {type(value)}')\"\n                    c1 = c + \" \" + printc\n                    # print(f\"{c} => {printmsg} : \")      \n                    output = f\"{c} => {printmsg} : \"\n                    print('{:>157}'.format(output))   \n                    exec(c1, globals().update(env))\n                \n                else:\n                    printc = \"print(f'{variables} : {eval(variables)}')\"\n                    printmsg = \"print(f'i : {variables}')\"\n                    c1 = c + \" \" + printc\n                    # print(f\"{c} => {printmsg} : \")     \n                    output = f\"{c} => {printmsg} : \"\n                    print('{:>157}'.format(output))   \n                    exec(c1, globals().update(env))\n                    \n            # if the code in string is like 'for k, v in abc: print(abc)'\n            else:                 \n                # \"for k, v in abc: print(k)\".split(': ', 1)[1] to get 'print(k)'\n                printc = c.split(': ', 1)[1]\n                # print(f\"{c} => {printc} : \")\n                output = f\"{c} => {printc} : \"\n                print('{:>157}'.format(output))   \n                exec(c, globals().update(env)) # we can't use eval to run `for in` loop, but exec can.\n            ### Note: we shall not use the expression like `for k, v in abc print(abc)`\n            ### Note: we shall not use the expression like `for k, v in abc if k == def`\n        \n        \n        # handle evaluation\n        else: \n            # print(f\"{c} => {c} : {eval(c, globals().update(env))}\") \n            output = f\"{c} => {c} : {eval(c, globals().update(env))}\"\n            print('{:>157}'.format(output))   \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\n\nadd feature when handling assignment: 2. when = occur before if; 1. when no if only =\n\ndef dbprint(src:str, # the source to debug in str\n            cmt:str,\n            *code,   # a number of codes to run, each code is in str, e.g., \"a + b\", \"c = a - b\"\n            **env\n           ):  # a number of stuff needed to run the code, e.g. var1 = var1, func1 = func1\n    \"Insert and run your codes and give readable output during debugging. Caution 1: \\\n    avoid using the same variable name used in both global and local scopes, e.g., \\\n    use `k` in the func and use `k` again inside a for loop inside the func.\\\n    Caution 2: make sure to include all the necessary env variables to avoid \\\n    the same variable with different values from different scopes. Caution 3: when an env variable is updated, \\\n    then you need to includ it again in the next dbprint. Caution 4: be strict on the spaces, e.g., `for k,v in` \\\n    and `a = createsth(...)`\"\n    \n    # Inside the source code, ff you ever add a block of multiline codes like `for in` or `if`, and run dbprint for each line of the block, then set \n    # defaults.block to True\n    if defaults.block == True:\n        print('\\n')\n        print('{:>157}'.format(\"===source inside a block===\"))\n        print('{:>157}'.format(src))\n        print('\\n')\n        # print(src + \"<===== source code =======\") \n\n    else:\n        print('\\n')\n        # print('{:>157}'.format(\"======================== source code ===========================\"))\n        print('{:#^157}'.format(\" source code with lines under investigation \"))\n        print('\\n')\n        # print('{:<157}'.format(src))        \n        \n        # print the source code of the function\n        lst = defaults.src.split('\\n')\n\n        ccount = 0\n        for l in lst: \n            if bool(l) and l.strip() in src: # how to make sure all these ls are close to each other???\n                print('{:=<157}'.format(l))\n                \n                if bool(cmt):\n                    clst = cmt.split('\\n') \n                    if ccount <= len(clst)-1:\n                        print('{:>157}'.format(colorize(clst[ccount], \"r\")))\n                        ccount = ccount + 1\n\n            else: \n                print('{:<157}'.format(l))\n\n        # print out the example\n        print('{:<157}'.format(defaults.eg))\n        \n    \n    # trial and error version for real code, still not quite why globals vs locals work in exec and eval\n    for c in code:\n        print(\"\\n\")\n        \n        # handle a block of code\n        if \"\\n\" in c: \n            output = f\"Running your code block => \"\n            print('{:<157}'.format(c))       \n            print('{:>157}'.format(output))  \n            print('The code block printout => : ')\n            block = ast.parse(c, mode='exec')\n            exec(compile(block, '<string>', mode='exec'), globals().update(env))\n        \n        # handle assignment: 2. when = occur before if; 1. when no if only =\n        elif (\"=\" in c and \"if\" not in c) or (\"=\" in c and c.find(\"=\") < c.find(\"if\")): # make sure assignment and !== and == are differentiated\n            \n            # print('k' in locals())\n            exec(c, globals().update(env)) \n            # print('k' in locals())\n            variable = c.partition(\" = \")[0]\n            # print(f\"{c} => {variable}: {eval(variable)}\")\n            output = f\"{c} => {variable}: {eval(variable)}\"\n            print('{:>157}'.format(output))       \n            \n        # handle if statement\n        # Note: do insert code like this : `if abc == def: print(abc)`, print is a must\n        elif \"if\" in c: \n            cond = re.search('if (.*?):', c).group(1)\n            \n            # when code in string is like 'if abc == def:'\n            if c.endswith(':'):\n                \n                # print ... \n                # print(f\"{c} => {cond}: {eval(cond)}\")      \n                output = f\"{c} => {cond}: {eval(cond)}\"\n                print('{:>157}'.format(output))\n                \n            # when code in string is like 'if abc == def: print(...)'\n            else: \n                # if the cond is true, then print ...\n                if eval(cond):\n                    \n                    # \"if abc == def: print(abc)\".split(': ', 2)[1] to get 'print(abc)'\n                    printc = c.split(': ', 1)[1]\n                    # print(f\"{c} => {printc} : \")\n                    output = f\"{c} => {printc} : \"\n                    print('{:>157}'.format(output))      \n                    exec(c, globals().update(env))\n                    \n                # if cond is false, then print ...\n                else: \n                    # print(f\"{c} => {cond}: {eval(cond)}\")\n                    output = f\"{c} => {cond}: {eval(cond)}\"\n                    print('{:>157}'.format(output))   \n                \n                \n        # handle for in statement\n        elif \"for \" in c and \" in \" in c:           \n            \n            # in example like 'for k, v in abc:' or `for k, v in abc: print(...)`, if abc is empty\n            # step 1: access abc\n            # get the substring between 'in ' and ':', which is like 'abc'\n            abc = re.search('in (.*?):', c).group(1)\n            # if abc is empty dict or list: print and pass\n            if not bool(eval(abc)): \n                # print(f'{c} => {abc} is an emtpy {type(eval(abc))}')\n                output = f'{c} => {abc} is an emtpy {type(eval(abc))}'\n                print('{:>157}'.format(output))   \n                continue \n                # The break statement can be used if you need to break out of a for or while loop and move onto the next section of code.\n                # The continue statement can be used if you need to skip the current iteration of a for or while loop and move onto the next iteration.\n            \n            # if the code in string is like 'for k, v in abc:', there is no more code after `:`\n            if c.endswith(':'):\n                \n                # get the substring between 'for ' and ' in', which is like 'k, v'\n                variables = re.search('for (.*?) in', c).group(1)\n                \n                # if variables has a substring like ', ' inside\n                if (',') in variables: \n                    \n                    # split it by ', ' into a list of substrings\n                    vl = variables.split(',')\n                    key = vl[0]\n                    value = vl[1]\n                    \n                    # make sure key and value will get evaluated first before exec run\n                    # printc is for exec to run\n                    printc = \"print(f'{key}:{eval(key)}, {type(eval(key))} ; {value}:{eval(value)}, {type(eval(value))}')\" \n                    # printmsg is for reader to understand with ease\n                    printmsg = \"print(f'key: {key}, {type(key)} ; value: {value}, {type(value)}')\"\n                    c1 = c + \" \" + printc\n                    # print(f\"{c} => {printmsg} : \")      \n                    output = f\"{c} => {printmsg} : \"\n                    print('{:>157}'.format(output))   \n                    exec(c1, globals().update(env))\n                \n                else:\n                    printc = \"print(f'{variables} : {eval(variables)}')\"\n                    printmsg = \"print(f'i : {variables}')\"\n                    c1 = c + \" \" + printc\n                    # print(f\"{c} => {printmsg} : \")     \n                    output = f\"{c} => {printmsg} : \"\n                    print('{:>157}'.format(output))   \n                    exec(c1, globals().update(env))\n                    \n            # if the code in string is like 'for k, v in abc: print(abc)'\n            else:                 \n                # \"for k, v in abc: print(k)\".split(': ', 1)[1] to get 'print(k)'\n                printc = c.split(': ', 1)[1]\n                # print(f\"{c} => {printc} : \")\n                output = f\"{c} => {printc} : \"\n                print('{:>157}'.format(output))   \n                exec(c, globals().update(env)) # we can't use eval to run `for in` loop, but exec can.\n            ### Note: we shall not use the expression like `for k, v in abc print(abc)`\n            ### Note: we shall not use the expression like `for k, v in abc if k == def`\n        \n        \n        # handle evaluation\n        else: \n            # print(f\"{c} => {c} : {eval(c, globals().update(env))}\") \n            output = f\"{c} => {c} : {eval(c, globals().update(env))}\"\n            print('{:>157}'.format(output))   \n            \n        # the benefit of using global().update(env) is \n        # to ensure we don't need to include the same env for the second time\n\n\n\nalignright the colored comment\n\n\n\ndbprint\n\n dbprint (src:str, cmt:str, *code, **env)\n\nInsert and run your codes and give readable output during debugging. Caution 1: avoid using the same variable name used in both global and local scopes, e.g., use k in the func and use k again inside a for loop inside the func. Caution 2: make sure to include all the necessary env variables to avoid the same variable with different values from different scopes. Caution 3: when an env variable is updated, then you need to includ it again in the next dbprint. Caution 4: be strict on the spaces, e.g., for k,v in and a = createsth(...)\n\n\n\n\nType\nDetails\n\n\n\n\nsrc\nstr\nthe source to debug in str\n\n\ncmt\nstr\n\n\n\ncode\n\n\n\n\nenv"
  },
  {
    "objectID": "utils.html#insert-dbprint-and-make-a-new-source-function-for-debugging-line-by-line",
    "href": "utils.html#insert-dbprint-and-make-a-new-source-function-for-debugging-line-by-line",
    "title": "debuggable utils",
    "section": "insert dbprint and make a new source function for debugging line by line",
    "text": "insert dbprint and make a new source function for debugging line by line\n\ndef insert2debug(name:str, # name of a function to debug, e.g., delegates\n                 srcline:str, # e.g., \"        if hasattr(from_f,'__delwrap__'): return f\"\n                 dbcode:str,  # str, e.g., \"dbprint(...)\"\n                 **env):\n    \"select a line or a block of source code and insert a dbprint above it and only output this dbprint result.\"\n    srcode = inspect.getsource(eval(name, globals().update(env)))\n    lstxt = srcode.split(srcline)\n    retn = \"\\n        return None\\n\"\n    insert = colorize(dbcode, \"g\") + colorize(srcline, \"r\") + colorize(retn, \"y\")\n    src2print = lstxt[0] + insert + lstxt[1]\n    for l in src2print.split(\"\\n\"):  # print out the debuggable version of delegates\n        print(l)\n    src2db = lstxt[0] + dbcode + srcline + retn + lstxt[1]\n    exec(src2db, globals().update({'srcline': srcline})) # now a debuggable version of delegates is available to use\n    globals().update({name:eval(name)})\n    return eval(name) # give this debuggable version of delegates to the notebook context\n\n\ninsert2debug??\n\n\nSignature: insert2debug(name: str, srcline: str, dbcode: str, **env)\nSource:   \ndef insert2debug(name:str, # name of a function to debug, e.g., delegates\n                 srcline:str, # e.g., \"        if hasattr(from_f,'__delwrap__'): return f\"\n                 dbcode:str,  # str, e.g., \"dbprint(...)\"\n                 **env):\n    \"select a line or a block of source code and insert a dbprint above it and only output this dbprint result.\"\n    srcode = inspect.getsource(eval(name, globals().update(env)))\n    lstxt = srcode.split(srcline)\n    retn = \"\\n        return None\\n\"\n    insert = colorize(dbcode, \"g\") + colorize(srcline, \"r\") + colorize(retn, \"y\")\n    src2print = lstxt[0] + insert + lstxt[1]\n    for l in src2print.split(\"\\n\"):  # print out the debuggable version of delegates\n        print(l)\n    src2db = lstxt[0] + dbcode + srcline + retn + lstxt[1]\n    exec(src2db, globals().update({'srcline': srcline})) # now a debuggable version of delegates is available to use\n    globals().update({name:eval(name)})\n    return eval(name) # give this debuggable version of delegates to the notebook context\nFile:      /var/folders/gz/ch3n2mp51m9386sytqf97s6w0000gn/T/ipykernel_90372/435102324.py\nType:      function\n\n\n\n\n\nremove return None, so that we can run multiple delegates in one cell without error\n\ndef insert2debug(name:str, # name of a function to debug, e.g., delegates\n                 srcline:str, # e.g., \"        if hasattr(from_f,'__delwrap__'): return f\"\n                 dbcode:str,  # str, e.g., \"dbprint(...)\"\n                 **env):\n    \"select a line or a block of source code and insert a dbprint above it and only output this dbprint result.\"\n    \n    srcode = inspect.getsource(eval(name, globals().update(env)))\n    lstxt = srcode.split(srcline)\n    # retn = \"\\n        return None\\n\"\n    retn = \"\"\n    insert = colorize(dbcode, \"g\") + colorize(srcline, \"r\") + colorize(retn, \"y\")\n    src2print = lstxt[0] + insert + lstxt[1]\n    for l in src2print.split(\"\\n\"):  # print out the debuggable version of delegates\n        print(l)\n    src2db = lstxt[0] + dbcode + srcline + retn + lstxt[1]\n    exec(src2db, globals().update({'srcline': srcline})) # now a debuggable version of delegates is available to use\n    # globals().update({name:eval(name)})\n    return eval(name) # give this debuggable version of delegates to the notebook context\n\n\ndef insert2debug(name:str, # name of a function to debug, e.g., delegates\n                 srcline:str, # e.g., \"        if hasattr(from_f,'__delwrap__'): return f\"\n                 dbcode:str,  # str, e.g., \"dbprint(...)\"\n                 **env):\n    \"select a line or a block of source code and insert a dbprint above it and only output this dbprint result.\"\n    \n    # defaults.multi default to False, unless set True, defaults.deb is default to None before debugging srcode\n    if defaults.multi and bool(defaults.deb): \n        srcode = defaults.deb\n    else: \n        # srcode = inspect.getsource(eval(name, globals().update(env)))\n        srcode = defaults.src\n    lstxt = srcode.split(srcline)\n    retn = \"\" # retn = \"\\n        return None\\n\" to exit the function, \"\" to continue on\n    insert = colorize(dbcode, \"g\") + colorize(srcline, \"r\") + colorize(retn, \"y\")\n    src2print = lstxt[0] + insert + lstxt[1]\n    for l in src2print.split(\"\\n\"):  # print out the debuggable version of delegates\n        print(l)\n    src2db = lstxt[0] + dbcode + srcline + retn + lstxt[1]\n    if defaults.multi: defaults.deb = src2db\n    exec(src2db, globals().update({'srcline': srcline})) # now a debuggable version of delegates is available to use\n    # globals().update({name:eval(name)})\n    return eval(name) # give this debuggable version of delegates to the notebook context\n\n\n\nmajor problems solved\n\ndef insert2debug(name:str, # name of a function to debug, e.g., delegates\n                 srcline:str, # e.g., \"        if hasattr(from_f,'__delwrap__'): return f\"\n                 dbcode:str,  # str, e.g., \"dbprint(...)\"\n                 run:bool=True, # run exec or not\n                 **env):\n    \"select a line or a block of source code and insert a dbprint above it and only output this dbprint result.\"\n    \n    # defaults.multi default to False, unless set True, defaults.deb is default to None before debugging srcode\n    if defaults.multi and bool(defaults.deb): \n        srcode = defaults.deb\n    else: \n        # srcode = inspect.getsource(eval(name, globals().update(env)))\n        srcode = defaults.src\n    lstxt = srcode.split(srcline)\n    retn = \"\" # retn = \"\\n        return None\\n\" to exit the function, \"\" to continue on\n    insert = colorize(dbcode, \"g\") + colorize(srcline, \"r\") + colorize(retn, \"y\")\n    src2print = lstxt[0] + insert + lstxt[1]\n            \n    src2db = lstxt[0] + dbcode + srcline + retn + lstxt[1]\n    # if defaults.multi: defaults.deb = src2db\n    defaults.deb = src2db\n    \n    # to exec \n    if run: \n        exec(src2db, globals().update({'srcline': srcline})) # now a debuggable version of delegates is available to use\n        # globals().update({name:eval(name)})\n        return eval(name) # give this debuggable version of delegates to the notebook context\n    # to not exec but only get the full debuggable source \n    else: \n        return None\n\n\n\ndebugging error\n\n\n\ninsert2debug\n\n insert2debug (name:str, srcline:str, dbcode:str, run:bool=True,\n               dberror:bool=False, **env)\n\nselect a line or a block of source code and insert a dbprint above it and only output this dbprint result.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\n\nname of a function to debug, e.g., delegates\n\n\nsrcline\nstr\n\ne.g., ” if hasattr(from_f,‘delwrap’): return f”\n\n\ndbcode\nstr\n\nstr, e.g., “dbprint(…)”\n\n\nrun\nbool\nTrue\nrun exec or not\n\n\ndberror\nbool\nFalse\nchoose to debug error in source code by setting return None or not\n\n\nenv\n\n\n\n\n\n\n\ninsert2debug??\n\n\nSignature:\ninsert2debug(\n    name: str,\n    srcline: str,\n    dbcode: str,\n    run: bool = True,\n    dberror: bool = False,\n    **env,\n)\nSource:   \ndef insert2debug(name:str, # name of a function to debug, e.g., delegates\n                 srcline:str, # e.g., \"        if hasattr(from_f,'__delwrap__'): return f\"\n                 dbcode:str,  # str, e.g., \"dbprint(...)\"\n                 run:bool=True, # run exec or not\n                 dberror:bool=False, # choose to debug error in source code by setting return None or not\n                 **env):\n    \"select a line or a block of source code and insert a dbprint above it and only output this dbprint result.\"\n    \n    # defaults.multi default to False, unless set True, defaults.deb is default to None before debugging srcode\n    if defaults.multi and bool(defaults.deb): \n        srcode = defaults.deb\n    else: \n        # srcode = inspect.getsource(eval(name, globals().update(env)))\n        srcode = defaults.src\n    lstxt = srcode.split(srcline)\n    retn = \"\" \n    if dberror: \n        retn = retn + \"\\n        return None\\n\" #  to exit the function, \"\" to continue on\n    insert = colorize(dbcode, \"g\") + colorize(srcline, \"r\") + colorize(retn, \"y\")\n    src2print = lstxt[0] + insert + lstxt[1]\n            \n    src2db = lstxt[0] + dbcode + retn + srcline + lstxt[1] # make sure return is before srcline and after dbcode\n    # if defaults.multi: defaults.deb = src2db\n    defaults.deb = src2db\n    \n    # to exec \n    if run: \n        exec(src2db, globals().update({'srcline': srcline})) # now a debuggable version of delegates is available to use\n        # globals().update({name:eval(name)})\n        return eval(name) # give this debuggable version of delegates to the notebook context\n    # to not exec but only get the full debuggable source \n    else: \n        return None\nFile:      /var/folders/gz/ch3n2mp51m9386sytqf97s6w0000gn/T/ipykernel_90372/2335954138.py\nType:      function\n\n\n\n\n\ndef dbsrclines(srcname:str, # name of the source code, e.g., delegates\n               lines:list = None # if None then print all e.g., defaults.src2dbp.delegates\n              ): \n    \"Doing one line or multilines of insert2debug on source code with dbprints.\"\n    srcdblist = eval(\"defaults.src2dbp.\" + srcname)\n    srcdblist = L(srcdblist)\n    \n    if not bool(lines):\n        for i in srcdblist:\n            pprint(i[0][0], width=157)\n            pprint(i[0][1], width=157)\n            print(\"\")\n        return None\n    \n    if len(lines) > 1: \n        defaults.multi = True\n        for i in eval(\"srcdblist\" + str(lines)):\n            delegates = insert2debug(srcname, i[0][0], i[0][1])\n    else: \n        item = eval(\"srcdblist\" + str(lines))\n        delegates = insert2debug(srcname, item[0][0], item[0][1])\n    \n\n    defaults.multi = False\n    defaults.deb = None\n    return delegates\n\n\nfor i in L([[(1,2)],[(2,2)]]): \n    print(i)\n\n[(1, 2)]\n[(2, 2)]"
  },
  {
    "objectID": "utils.html#exporting-the-debuggable-source-and-major-problems-solved",
    "href": "utils.html#exporting-the-debuggable-source-and-major-problems-solved",
    "title": "debuggable utils",
    "section": "Exporting the debuggable source and major problems solved",
    "text": "Exporting the debuggable source and major problems solved\n\ndef dbsrclines(srcname:str, # name of the source code, e.g., delegates\n               lines:list = None, # if None then print all e.g., defaults.src2dbp.delegates\n               dbsrc:bool = False # get the full debuggable source code\n              ): \n    \"Doing one line or multilines of insert2debug on source code with dbprints.\"\n    srcdblist = eval(\"defaults.src2dbp.\" + srcname)\n    srcdblist = L(srcdblist)\n    \n    if not bool(lines) and dbsrc == False: # to print out the source code and mark all the srclines \n        for i in srcdblist:\n            pprint(i[0][0], width=157)\n            pprint(i[0][1], width=157)\n            print(\"\")\n        return None\n     \n    if dbsrc and not bool(lines): # to print out the entire debuggable source code\n        defaults.multi = True\n        for i in srcdblist:\n            insert2debug(srcname, i[0][0], i[0][1], run=False) # don't exec just add up debuggable source\n        # export the debuggable source\n        defaults.src2dbp.delegatesdb = defaults.deb\n        pprint(defaults.src2dbp.delegatesdb, width=157)\n        defaults.deb = None\n        defaults.multi = False\n        return None\n    \n    if len(lines) > 1: \n        defaults.multi = True\n        for i in eval(\"srcdblist\" + str(lines)):\n            delegates = insert2debug(srcname, i[0][0], i[0][1])\n\n    else: \n        item = eval(\"srcdblist\" + str(lines))\n        delegates = insert2debug(srcname, item[0][0], item[0][1])\n\n    pprint(defaults.deb, width=157) # print the debuggable source\n\n    defaults.multi = False\n    defaults.deb = None\n    return delegates\n\n\nimprove the print feature of dbscrlines\n\ndef dbsrclines(srcname:str, # name of the source code, e.g., delegates\n               lines:list = None, # if None then print all e.g., defaults.src2dbp.delegates\n               dbsrc:bool = False # get the full debuggable source code\n              ): \n    \"Doing one line or multilines of insert2debug on source code with dbprints.\"\n    srcdblist = eval(\"defaults.src2dbp.\" + srcname)\n    srcdblist = L(srcdblist)\n    \n    if not bool(lines) and dbsrc == False: # to print out the source code and mark all the srclines \n        # put all srclines into a single string\n        srclines = \"\"\n        for i in srcdblist:\n            srclines = srclines + i[0][0]\n        \n        for l in defaults.src.split(\"\\n\"):\n            if l in srclines:\n                print('{:=<157}'.format(l))\n            else: \n                print('{:<157}'.format(l))\n        print(\"\")\n        return None\n     \n    if dbsrc and not bool(lines): # set dbsrc to true to export the entire debuggable source code to defaults.src2dbp.delegatesdb\n        defaults.multi = True\n        for i in srcdblist:\n            insert2debug(srcname, i[0][0], i[0][1], run=False) # don't exec just add up debuggable source\n        # export the debuggable source\n        defaults.src2dbp.delegatesdb = defaults.deb\n        # pprint(defaults.src2dbp.delegatesdb, width=157)\n        defaults.deb = None\n        defaults.multi = False\n        return None\n    \n    if len(lines) > 1: \n        defaults.multi = True\n        for i in eval(\"srcdblist\" + str(lines)):\n            delegates = insert2debug(srcname, i[0][0], i[0][1])\n\n    else: \n        item = eval(\"srcdblist\" + str(lines))\n        delegates = insert2debug(srcname, item[0][0], item[0][1])\n\n    pprint(defaults.deb, width=157) # print the debuggable source\n\n    defaults.multi = False\n    defaults.deb = None\n    return delegates\n\n\n\nadd return to the last dbcode for debugging examples which cause errors\n\n\n\ndbsrclines\n\n dbsrclines (srcname:str, lines:list=None, dbsrc:bool=False,\n             retn:bool=False)\n\nDoing one line or multilines of insert2debug on source code with dbprints.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsrcname\nstr\n\nname of the source code, e.g., delegates\n\n\nlines\nlist\nNone\nif None then print all e.g., defaults.src2dbp.delegates\n\n\ndbsrc\nbool\nFalse\nget the full debuggable source code\n\n\nretn\nbool\nFalse\nchoose to add return None after the last dbcode"
  },
  {
    "objectID": "utils.html#check-official-source-against-debuggable-source",
    "href": "utils.html#check-official-source-against-debuggable-source",
    "title": "debuggable utils",
    "section": "check official source against debuggable source",
    "text": "check official source against debuggable source\n\n\nchecksrc\n\n checksrc (srcname)\n\ncheck src code against dbsource\n\n\n\nstrip_ansi\n\n strip_ansi (source)\n\n\n\n\nalignright\n\n alignright (blocks)\n\n\nalignright(\"this is me\")\nalignright(\"\\x1b[91mthis is me\\x1b[0m\")\n\n                                                                                                                                                   this is me\n                                                                                                                                                   this is me"
  },
  {
    "objectID": "utils.html#how-to-shuffle",
    "href": "utils.html#how-to-shuffle",
    "title": "debuggable utils",
    "section": "How to shuffle",
    "text": "How to shuffle\n\nsrc = \"    def low(a, b=1):\\n        c = b*2\\n        return a + b + c\"\n\n\nfor l in src.split(\"\\n\"): print(l)\n\n    def low(a, b=1):\n        c = b*2\n        return a + b + c\n\n\nI have a list of tuples, and the first item of each tuple contains a line of the function above. The problem is the order of the lines are random.\n\nsrcshuffled = [[(\"        return a + b + c\", \"this is the end of the func\")],[(\"        c = b*2\", \"first line inside the func\")],[(\"    def low(a, b=1):\", \"this is where signature is\")]]\n\n\nfor s in srcshuffled:\n    print(s[0][0])\n\n        return a + b + c\n        c = b*2\n    def low(a, b=1):\n\n\nHow can I reorder the list so that the first item of each tuple matches the function in the right order?\n\nsrcorrect = [[(\"    def low(a, b=1):\", \"this is where signature is\")],[(\"        c = b*2\", \"first line inside the func\")], [(\"        return a + b + c\", \"this is the end of the func\")]]\n\n\nfor s in srcorrect:\n    print(s[0][0])\n\n    def low(a, b=1):\n        c = b*2\n        return a + b + c\n\n\nmy attempt\n\nfor idx, l in zip(range(len(src.split(\"\\n\"))), src.split(\"\\n\")):\n    print(idx)\n    print(l)\n\n0\n    def low(a, b=1):\n1\n        c = b*2\n2\n        return a + b + c\n\n\n\nsrcorrect1 = []\nfor l in src.split(\"\\n\"):\n    for s in srcshuffled: \n        if l.strip() in s[0][0]:\n            srcorrect1.append(s)\n\n\nfor s in srcorrect1:\n    print(s[0][0])\n\n    def low(a, b=1):\n        c = b*2\n        return a + b + c\n\n\n\n\nmatchsrcorder\n\n matchsrcorder (srcdbps:list)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nsrcdbps\nlist\nthe list contain all srclines and their dbcodes with random order"
  },
  {
    "objectID": "README.html",
    "href": "README.html",
    "title": "Fastai Debuggable",
    "section": "",
    "text": "from fastcore.meta import *\nfrom nbdev.showdoc import *\nfrom fastcore.test import *\nfrom pprint import pprint\nfrom debuggable.utils import *\nimport inspect"
  },
  {
    "objectID": "README.html#useful-tools-i-built",
    "href": "README.html#useful-tools-i-built",
    "title": "Fastai Debuggable",
    "section": "Useful tools I built",
    "text": "Useful tools I built\n\ndebuggable.utils.whatinside\n\nimport fastcore.meta as fm\nwhatinside(fm, dun=True)\n\nfastcore.meta has: \n13 items in its __all__, and \n43 user defined functions, \n19 classes or class objects, \n2 builtin funcs and methods, and\n74 callables.\n\n['test_sig',\n 'FixSigMeta',\n 'PrePostInitMeta',\n 'AutoInit',\n 'NewChkMeta',\n 'BypassNewMeta',\n 'empty2none',\n 'anno_dict',\n 'use_kwargs_dict',\n 'use_kwargs',\n 'delegates',\n 'method',\n 'funcs_kwargs']\n\nwhatinside(fm, func=True)\n\nfastcore.meta has: \n13 items in its __all__, and \n43 user defined functions, \n19 classes or class objects, \n2 builtin funcs and methods, and\n74 callables.\n\nThe user defined functions are:\n['_funcs_kwargs',\n '_mk_param',\n '_rm_self',\n 'all_equal',\n 'anno_dict',\n 'any_is_instance',\n 'array_equal',\n 'contextmanager',\n 'copy',\n 'delegates',\n 'df_equal',\n 'empty2none',\n 'equals',\n 'funcs_kwargs',\n 'in_colab',\n 'in_ipython',\n 'in_jupyter',\n 'in_notebook',\n 'ipython_shell',\n 'is_close',\n 'is_coll',\n 'is_iter',\n 'isinstance_str',\n 'method',\n 'nequals',\n 'noop',\n 'noops',\n 'remove_prefix',\n 'remove_suffix',\n 'test',\n 'test_close',\n 'test_eq',\n 'test_eq_type',\n 'test_fail',\n 'test_fig_exists',\n 'test_is',\n 'test_ne',\n 'test_shuffled',\n 'test_sig',\n 'test_stdout',\n 'test_warns',\n 'use_kwargs',\n 'use_kwargs_dict']\n\nwhatinside(fm, clas=True)\n\nfastcore.meta has: \n13 items in its __all__, and \n43 user defined functions, \n19 classes or class objects, \n2 builtin funcs and methods, and\n74 callables.\n\nThe class objects are:\n['AutoInit',\n 'BuiltinFunctionType',\n 'BuiltinMethodType',\n 'BypassNewMeta',\n 'ExceptionExpected',\n 'FixSigMeta',\n 'FunctionType',\n 'MethodDescriptorType',\n 'MethodType',\n 'MethodWrapperType',\n 'NewChkMeta',\n 'NoneType',\n 'Path',\n 'PrePostInitMeta',\n 'SimpleNamespace',\n 'WrapperDescriptorType',\n 'attrgetter',\n 'itemgetter',\n 'partial']\n\nwhatinside(fm, lib=True)\n\nfastcore.meta has: \n13 items in its __all__, and \n43 user defined functions, \n19 classes or class objects, \n2 builtin funcs and methods, and\n74 callables.\n\nThe library has 21 modules\n['_modidx',\n '_nbdev',\n 'all',\n 'basics',\n 'dispatch',\n 'docments',\n 'docscrape',\n 'foundation',\n 'imports',\n 'meta',\n 'nb_imports',\n 'net',\n 'parallel',\n 'script',\n 'shutil',\n 'style',\n 'test',\n 'transform',\n 'utils',\n 'xdg',\n 'xtras']\n\nimport fastcore.imports as fi\nwhatinside(fi, dun=True)\n\nfastcore.imports has: \n0 items in its __all__, and \n17 user defined functions, \n13 classes or class objects, \n2 builtin funcs and methods, and\n42 callables.\n\nwhatinside(fi, func=True)\n\nfastcore.imports has: \n0 items in its __all__, and \n17 user defined functions, \n13 classes or class objects, \n2 builtin funcs and methods, and\n42 callables.\n\nThe user defined functions are:\n['all_equal',\n 'any_is_instance',\n 'array_equal',\n 'df_equal',\n 'equals',\n 'in_colab',\n 'in_ipython',\n 'in_jupyter',\n 'in_notebook',\n 'ipython_shell',\n 'is_coll',\n 'is_iter',\n 'isinstance_str',\n 'noop',\n 'noops',\n 'remove_prefix',\n 'remove_suffix']\n\nwhatinside(fi, clas=True)\n\nfastcore.imports has: \n0 items in its __all__, and \n17 user defined functions, \n13 classes or class objects, \n2 builtin funcs and methods, and\n42 callables.\n\nThe class objects are:\n['BuiltinFunctionType',\n 'BuiltinMethodType',\n 'FunctionType',\n 'MethodDescriptorType',\n 'MethodType',\n 'MethodWrapperType',\n 'NoneType',\n 'Path',\n 'SimpleNamespace',\n 'WrapperDescriptorType',\n 'attrgetter',\n 'itemgetter',\n 'partial']\n\n\ndebuggable.utils.whichversion\n\nwhichversion('nbdev')\n\nnbdev: 2.1.7 \nCreate delightful software with Jupyter Notebooks    \nJeremy Howard and Hamel Husain \nhttps://github.com/fastai/nbdev     \npython_version: >=3.7     \n/Users/Natsume/mambaforge/lib/python3.9/site-packages/nbdev\n\nwhichversion('fastcore')\n\nfastcore: 1.5.18 \nPython supercharged for fastai development    \nJeremy Howard and Sylvain Gugger \nhttps://github.com/fastai/fastcore/     \npython_version: >=3.7     \n/Users/Natsume/Documents/fastcore/fastcore\n\nwhichversion('debuggable', req=True)\n\ndebuggable: 0.0.12 \nmake fastai library debuggable on every major line    \nEmbraceLife \nhttps://github.com/EmbraceLife/debuggable/     \npython_version: >=3.7     \n/Users/Natsume/Documents/debuggable/debuggable\n\ndebuggable requires: \n['fastcore', 'fastai', 'numpy']\n\n\ndebuggable.utils.dbprint\nplease go to my docs for fastcore.meta.delegates for demos of this function."
  },
  {
    "objectID": "README.html#my-contributions-to-fastcore",
    "href": "README.html#my-contributions-to-fastcore",
    "title": "Fastai Debuggable",
    "section": "My contributions to fastcore",
    "text": "My contributions to fastcore\n\nMy first contrib to fastcore is based on the solution above with Jeremy’s modification"
  },
  {
    "objectID": "README.html#interesting-findings-of-fastcore",
    "href": "README.html#interesting-findings-of-fastcore",
    "title": "Fastai Debuggable",
    "section": "Interesting findings of fastcore",
    "text": "Interesting findings of fastcore"
  },
  {
    "objectID": "fastcore/previous/fastcoremeta.html",
    "href": "fastcore/previous/fastcoremeta.html",
    "title": "fastcore_meta",
    "section": "",
    "text": "from nbdev.showdoc import *\nfrom IPython.display import IFrame\n\n\n\n\n\n\n\n\n<Signature (to: function = None, keep=False, but: list = None, verbose=True)>\n'Decorator: replace `**kwargs` in signature with params from `to`'\n\n\n\n\n\n        \n        \n\n\n\n\n\nmore examples\nassert foo(c=1, a=1) == 7\n\n\n\n\nonly keyword params (with default values) are delegated to foo from baz\nparams (both positional and keyword) from foo suffice to fill positional params of baz\n\n\n\n\n\ndef baz(a, b=2, c=3): return a + b + c\n\n@delegates(baz)\ndef foo1(d, a, **kwargs): # both b=2, c=3 are kept\n    return d + baz(a, **kwargs)\n\n@delegates(baz)\ndef foo2(c, a, **kwargs): # c in foo2 replaces c=3 in baz, only b=2 is kept\n    return c + baz(a, **kwargs)\n\ninspect.signature(foo1), inspect.signature(foo2)\n\n(<Signature (d, a, *, b=2, c=3)>, <Signature (c, a, *, b=2)>)\n\n\n\n\n\n\ntest_sig(foo2, '(c, a, *, b=2)')\n\n\n\n\n\nclass _T():\n    @classmethod\n    def foo(cls, a=1, b=2):\n        pass\n    \n    @classmethod\n    @delegates(foo)\n    def bar(cls, c=3, **kwargs):\n        pass\n\n\nt = _T()\ninspect.signature(t.bar)\n\n<Signature (c=3, *, a=1, b=2)>\n\n\n\nclass _T():\n    def foo(cls, a=1, b=2):\n        pass\n    \n    @delegates(foo)\n    def bar(cls, c=3, **kwargs):\n        pass\n\n\nt = _T()\ninspect.signature(t.bar)\n\n<Signature (c=3, *, a=1, b=2)>\n\n\n\n\n\n\nclass BaseFoo:\n    def __init__(self, e, c=2): pass\n\nclass Foo(BaseFoo):\n    def __init__(self, a, b=1, **kwargs): super().__init__(**kwargs)\n\ntest_sig(Foo, '(a, b=1, **kwargs)')\n\n\nclass BaseFoo:\n    def __init__(self, e, c=2): pass\n\n@delegates()# since no argument was passsed here we delegate to the superclass\nclass Foo(BaseFoo):\n    def __init__(self, a, b=1, **kwargs): super().__init__(**kwargs)\n\ntest_sig(Foo, '(a, b=1, *, c=2)')\n\n\n\n\n\nclass BaseFoo:\n    def __init__(self, e, c=2): pprint(locals())\n\nclass OtherFoo:\n    def __init__(self, d, f=1): pprint(locals())\n\n@delegates(OtherFoo)# since no argument was passsed here we delegate to the superclass\nclass Foo(BaseFoo):\n    def __init__(self, a, b=1, **kwargs): \n        pprint(locals())\n        super().__init__(**kwargs)\n\n# inspect.signature(Foo)\ntest_sig(Foo, '(a, b=1, *, f=1)')\n\n\ntry:        \n    f = Foo(1,1,f=1)\nexcept TypeError as e:\n    print(e)\n\n{'__class__': <class '__main__.Foo'>,\n 'a': 1,\n 'b': 1,\n 'kwargs': {'f': 1},\n 'self': <__main__.Foo object>}\n__init__() got an unexpected keyword argument 'f'\n\n\n\n\n\n\ndef low(a:int, b:int=1): pass\ndef mid(c:int, d:int=1, **kwargs): low(c, **kwargs) + d\ndef high(e:int, f:int=1, **kwargs): mid(e, **kwargs) + f\n\n\nprint(\"low: \")\npprint(inspect.signature(low))\nprint(\"mid: \")\npprint(inspect.signature(mid))\nprint(\"high: \")\npprint(inspect.signature(high))\n\nlow: \n<Signature (a: int, b: int = 1)>\nmid: \n<Signature (c: int, d: int = 1, **kwargs)>\nhigh: \n<Signature (e: int, f: int = 1, **kwargs)>\n\n\n\n\n\n\ndef low(a:int, b:int=1): pass\n@delegates(low)\ndef mid(c:int, d:int=1, **kwargs): low(c, **kwargs) + d\n@delegates(mid)\ndef high(e:int, f:int=1, **kwargs): mid(e, **kwargs) + f\n\n\nprint(\"low: \")\npprint(inspect.signature(low))\nprint(\"mid: \")\npprint(inspect.signature(mid))\nprint(\"high: \")\npprint(inspect.signature(high))\n\nlow: \n<Signature (a: int, b: int = 1)>\nmid: \n<Signature (c: int, d: int = 1, *, b: int = 1)>\nhigh: \n<Signature (e: int, f: int = 1, *, d: int = 1, b: int = 1)>\n\n\n\n\n\n\n\n\n\n@delegates(mid, keep=True, but=['b'])\ndef high(e:int, f:int=1, **kwargs): mid(e, **kwargs) + f\npprint(inspect.signature(high))\n\n<Signature (e: int, f: int = 1, *, d: int = 1, **kwargs)>\n\n\n\n\n\nUsing delegates?? to get its source code\ndef delegates(to=None, keep=False, but=None):\n    \"Decorator: replace `**kwargs` in signature with params from `to`\"\n    if but is None: but = []\n    def _f(f):\n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n        from_f = getattr(from_f,'__func__',from_f)\n        to_f = getattr(to_f,'__func__',to_f)\n        if hasattr(from_f,'__delwrap__'): return f\n        sig = inspect.signature(from_f)\n        sigd = dict(sig.parameters)\n        k = sigd.pop('kwargs')\n        s2 = {k:v for k,v in inspect.signature(to_f).parameters.items()\n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}\n        sigd.update(s2)\n        if keep: sigd['kwargs'] = k\n        else: from_f.__delwrap__ = to_f\n        from_f.__signature__ = sig.replace(parameters=sigd.values())\n        return f\n    return _f\n\ndef low(a:int, b:int=1): return a + b\ndef mid(c:int, d:int=1, **kwargs): return low(c, **kwargs) + d\n\n\nprint(mid(1))\ninspect.signature(mid)\n\n3\n\n\n<Signature (c: int, d: int = 1, **kwargs)>\n\n\n\n_f = delegates(low)\nmid = _f(mid)\nprint(mid(1))\n\ninspect.signature(mid)\n\n3\n\n\n<Signature (c: int, d: int = 1, *, b: int = 1)>\n\n\n@delegates(low) is equivalent to the first two lines in cell above\n\n\n\n\n\n\nFunction example\n\ndef low(a:int, b:int=1): return a + b\ndef mid(c:int, d:int=1, **kwargs): return low(c, **kwargs) + d\ndef high(e:int, f:int=1, **kwargs): return mid(e, **kwargs) + f\n\nClass example\n\nclass BaseFoo:\n    def __init__(self, e, c=2): pass\n\nclass OtherFoo:\n    def __init__(self, d, f=1): pass\n\nclass Foo(BaseFoo):\n    def __init__(self, a, b=1, **kwargs): super().__init__(**kwargs)\n\ndef delegates(to=None, keep=False, but=None):\n    \"Decorator: replace `**kwargs` in signature with params from `to`\"\n    if but is None: but = []\n    def _f(f):\n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n        from_f = getattr(from_f,'__func__',from_f)\n        to_f = getattr(to_f,'__func__',to_f)\n        if hasattr(from_f,'__delwrap__'): return f\n        sig = inspect.signature(from_f)\n        sigd = dict(sig.parameters)\n        k = sigd.pop('kwargs')\n        s2 = {k:v for k,v in inspect.signature(to_f).parameters.items()\n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}\n        sigd.update(s2)\n        if keep: sigd['kwargs'] = k\n        else: from_f.__delwrap__ = to_f\n        from_f.__signature__ = sig.replace(parameters=sigd.values())\n        return f\n    return _f\n\n\n\ndef delegates(to=None, keep=False, but=None):\n    \"Decorator: replace `**kwargs` in signature with params from `to`\"\n    if but is None: but = []\n\n# def delegates(to=None, keep=False, but=None):\n#     \"Decorator: replace `**kwargs` in signature with params from `to`\"\nto=mid     # `to` is the func to delegate its kwargs with default values to `f` func\nkeep=False # whether to keep `**kwargs` inside `f` signature or not\nbut=None   # which default kwargs to remove from `f` signature\nif but is None: but = [] # if not None, but should be a list type\n\n\n\n\n...\n    def _f(f):\n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n        from_f = getattr(from_f,'__func__',from_f)\n        to_f = getattr(to_f,'__func__',to_f)\n        ....\nWhat can to and f be? - function - class method, instant method - class - type?\nWhen dealing with class and superclass\n\nto = None\nf = Foo\nif to is None: to_f,from_f = f.__base__.__init__,f.__init__ # use delegates on class\nto_f, from_f\n\n(<function __main__.BaseFoo.__init__(self, e, c=2)>,\n <function __main__.Foo.__init__(self, a, b=1, **kwargs)>)\n\n\n\n\n\n\nfrom_f = getattr(from_f,'__func__',from_f)\nto_f = getattr(to_f,'__func__',to_f); to_f, from_f\n\n(<function __main__.BaseFoo.__init__(self, e, c=2)>,\n <function __main__.Foo.__init__(self, a, b=1, **kwargs)>)\n\n\n\n\n\n\nto = 1\nf = 34\nif True: to_f,from_f = 3 if to == 1 else to,f \nprint(to_f, from_f, f)\n\n3 34 34\n\n\n\nto = 1\nf = 34\nif True: \n    if to == 1: \n        to_f = 3\n        from_f = f\n    else: \n        to_f = to\n        from_f = f\nprint(to_f, from_f, f)\n\n3 34 34\n\n\n\n\n\nhow-type: learn more of type\n\nto = OtherFoo\nf = Foo\nprint(isinstance(to,type))\n# if isinstance(to,type): to_f,from_f = to.__init__ \nif to is None: to_f,from_f = f.__base__.__init__,f.__init__ # use delegates on class\nelse:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f \nto_f, from_f\n\nTrue\n\n\n(<function __main__.OtherFoo.__init__(self, d, f=1)>, __main__.Foo)\n\n\n\nfrom_f = getattr(from_f,'__func__',from_f)\nto_f = getattr(to_f,'__func__',to_f);  to_f, from_f\n\n(<function __main__.OtherFoo.__init__(self, d, f=1)>, __main__.Foo)\n\n\nWorking with function\n\n# def _f(f):\nto = low\nf = mid\nif to is None: to_f,from_f = f.__base__.__init__,f.__init__ # use delegates on class\nelse:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f \n                                         # secret use of delegates on type\n                                         # finally delegates on functions\nto_f, from_f\n\n(<function __main__.low(a: int, b: int = 1)>,\n <function __main__.mid(c: int, d: int = 1, **kwargs)>)\n\n\n\nfrom_f = getattr(from_f,'__func__',from_f)\nto_f = getattr(to_f,'__func__',to_f);  to_f, from_f\n\n(<function __main__.low(a: int, b: int = 1)>,\n <function __main__.mid(c: int, d: int = 1, **kwargs)>)\n\n\n\n\n\nsee when __delwrap__ attr is set below.\nif hasattr(from_f,'__delwrap__'): return f # don't do it more than once\n\n\n\n\nhasattr(from_f,'__delwrap__') == False\n\nTrue\n\n\n\npprint(inspect.signature(from_f))\nhasattr(from_f,'__signature__') == False\n\n<Signature (c: int, d: int = 1, **kwargs)>\n\n\nTrue\n\n\nFunction Example\n\ndef low(a, b:int=1): pass\n@delegates(low)\ndef mid(c, d:int=1, **kwargs): pass\ninspect.signature(mid)\n\n<Signature (c, d: int = 1, *, b: int = 1)>\n\n\n\nmid.__delwrap__, hasattr(mid, '__delwrap__')\n\n(<function __main__.low(a, b: int = 1)>, True)\n\n\nClass Example\n\nclass BaseFoo:\n    def __init__(self, e, c=2): pass\n\n@delegates()# since no argument was passsed here we delegate to the superclass\nclass Foo(BaseFoo):\n    def __init__(self, a, b=1, **kwargs): super().__init__(**kwargs)\n        \ninspect.signature(Foo)\n\n<Signature (a, b=1, *, c=2)>\n\n\n\nFoo.__init__.__delwrap__, hasattr(Foo.__init__, '__delwrap__')\n\n(<function __main__.BaseFoo.__init__(self, e, c=2)>, True)\n\n\n\n\n\nYou could do it with no @, but no useful usecases for it.\n\ndef low(a, b:int=1): pass\ndef mid(c, d:int=1, **kwargs): pass\ninspect.signature(mid)\n\n<Signature (c, d: int = 1, **kwargs)>\n\n\n\nmid1 = delegates(low, keep=True)(mid)\ntest_sig(mid, '(c, d: int = 1, *, b: int = 1, **kwargs)')\ndef low1(a1, b1:int=1): pass\nmid2 = delegates(low1, keep=True)(mid)\ntest_sig(mid, '(c, d: int = 1, *, b: int = 1, b1: int = 1, **kwargs)')\n\n\n\n\n...\n    def _f(f):\n        ...\n        \n        sig = inspect.signature(from_f)\n        sigd = dict(sig.parameters)\n        k = sigd.pop('kwargs')\n        s2 = {k:v for k,v in inspect.signature(to_f).parameters.items()\n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}\n        sigd.update(s2)\n\n        ...\n        return f\n    return _f\n\n\n\n\nsig = inspect.signature(from_f) # get signature\nprint(sig, \"\\n\")\n\nsigd = dict(sig.parameters) # turn signature into a dict\npprint(sigd)\nk = sigd.pop('kwargs') # take **kwargs parameter out of the dict and keep it\n\nprint(\"\")\npprint(k) # **kwargs parameter\npprint(sig) # unchanged\npprint(sigd) # changed\n\n(c: int, d: int = 1, **kwargs) \n\n{'c': <Parameter \"c: int\">,\n 'd': <Parameter \"d: int = 1\">,\n 'kwargs': <Parameter \"**kwargs\">}\n\n<Parameter \"**kwargs\">\n<Signature (c: int, d: int = 1, **kwargs)>\n{'c': <Parameter \"c: int\">, 'd': <Parameter \"d: int = 1\">}\n\n\n\n\n\n\ndef low(a, b:int=1): pass\n\ntry:\n    @delegates(low)\n    def mid(c, d:int=1): pass\nexcept KeyError as e:\n    print(f\"when mid has no **kwargs parameter in its signature, fastcore.delegates will throw an KeyError: {e}\")\n\nwhen mid has no **kwargs parameter in its signature, fastcore.delegates will throw an KeyError: 'kwargs'\n\n\n\n\n\nThose kwargs must meet 3 conditions - have default values or != inspect.Parameter.empty - not conflict with parameters in f - not in the list of but\n\ndef low(a, b:int=1, c:int=2, e:int=1): pass\ndef mid(c, d:int=1, **kwargs): pass\nto_f = low\nsig = inspect.signature(mid)\npprint(sig.parameters)\nsigd = dict(sig.parameters) # Note: sig.parameters\nk = sigd.pop(\"kwargs\")\nbut = ['b']\ns2 = {k:v for k,v in inspect.signature(to_f).parameters.items()\n      if v.default != inspect.Parameter.empty and k not in sigd and k not in but}; \ns2 # is empty dict because c is part of `mid` too, b is in the `but` list\n\nmappingproxy(OrderedDict([('c', <Parameter \"c\">),\n                          ('d', <Parameter \"d: int = 1\">),\n                          ('kwargs', <Parameter \"**kwargs\">)]))\n\n\n{'e': <Parameter \"e: int = 1\">}\n\n\n\n\n\n\ns2 = {name: param.replace(kind=inspect.Parameter.KEYWORD_ONLY) for name, param in s2.items()} \ns2['e'].kind\n\n<_ParameterKind.KEYWORD_ONLY: 3>\n\n\n\n\n\nif v.default != inspect.Parameter.empty\n\n\n\n\nsigd.update(s2); sigd\n\n{'c': <Parameter \"c\">,\n 'd': <Parameter \"d: int = 1\">,\n 'e': <Parameter \"e: int = 1\">}\n\n\n\n\n\n...\n    def _f(f):\n        ...\n        if keep: sigd['kwargs'] = k\n        else: from_f.__delwrap__ = to_f\n        from_f.__signature__ = sig.replace(parameters=sigd.values())\n        return f\n    return _f\n\ndef low(a, b=1): pass\ndef mid(c, d, **kwargs): pass\nhasattr(mid, '__signature__')\n\nFalse\n\n\n\ndef low(a, b=1): pass\n@delegates(low)\ndef mid(c, d, **kwargs): pass\nhasattr(mid, '__signature__')\n\nTrue\n\n\n\n\n\n\n\n\n\ntry: \n    from_f.__delwrap__\nexcept AttributeError as e:\n    print(e)\n    \nto_f, from_f\n\n'function' object has no attribute '__delwrap__'\n\n\n(<function __main__.low(a, b: int = 1, c: int = 2, e: int = 1)>,\n <function __main__.mid(c: int, d: int = 1, **kwargs)>)\n\n\n\nkeep = False\nif keep == False: from_f.__delwrap__ = to_f # another way to set attr\nfrom_f.__delwrap__\n\n<function __main__.low(a, b: int = 1, c: int = 2, e: int = 1)>\n\n\n\n\n\n\ndef tst(): pass\ntst.__setattr__(\"__delwrap__\", \"a\")\nprint(tst.__delwrap__)\ntst.__delwrap__ = \"b\"\nprint(tst.__delwrap__)\ntst.__delattr__(\"__delwrap__\")\ntry: \n    print(tst.__delwrap__)\nexcept: \n    print(\"no more\")\n\na\nb\nno more\n\n\n\n\n\n\nsigd\n\n{'c': <Parameter \"c\">,\n 'd': <Parameter \"d: int = 1\">,\n 'e': <Parameter \"e: int = 1\">}\n\n\n\n\n\n\nsigd.items()\n\ndict_items([('c', <Parameter \"c\">), ('d', <Parameter \"d: int = 1\">), ('e', <Parameter \"e: int = 1\">)])\n\n\n\n\n\n\nsigd.values()\n\ndict_values([<Parameter \"c\">, <Parameter \"d: int = 1\">, <Parameter \"e: int = 1\">])\n\n\n\n\n\n\npprint(inspect.getdoc(sig.replace))\n\n('Creates a customized copy of the Signature.\\n'\n \"Pass 'parameters' and/or 'return_annotation' arguments\\n\"\n 'to override them in the new copy.')\n\n\n\ntry:\n    from_f.__signature__\nexcept AttributeError as e:\n    print(e)\n\nfrom_f\n\n'function' object has no attribute '__signature__'\n\n\n<function __main__.mid(c: int, d: int = 1, **kwargs)>\n\n\n\nfrom_f.__signature__ = sig.replace(parameters=sigd.values())\npprint(from_f.__signature__)\n\n<Signature (c, d: int = 1, *, e: int = 1)>\n\n\n\nfrom_f\n\n<function __main__.mid(c, d: int = 1, *, e: int = 1)>\n\n\n\n# return _f\n\n\n\n\n\n\ndef low(a:int,   \n        b:int=1, \n       ):\n    print(\"the locals of low: \")\n    pprint(locals())\n    return a + b\n\n@delegates(low)\ndef mid(c:int,   \n        d:int=1, \n        **kwargs \n       ):\n    print(\"the locals of mid: \")\n    pprint(locals())\n    return low(c, **kwargs) + d\n\n@delegates(mid)\ndef high(e:int,   \n         f:int=1, \n         **kwargs \n        ):\n    print(\"the locals of high: \")\n    pprint(locals())\n    return mid(e, **kwargs) + f\n\n\nmid(c=2,d=1,b=1) # use shift + tab\n\nthe locals of mid: \n{'c': 2, 'd': 1, 'kwargs': {'b': 1}}\nthe locals of low: \n{'a': 2, 'b': 1}\n\n\n4\n\n\n\nhigh(e=2,f=1,d=1,b=1)\n\nthe locals of high: \n{'e': 2, 'f': 1, 'kwargs': {'b': 1, 'd': 1}}\nthe locals of mid: \n{'c': 2, 'd': 1, 'kwargs': {'b': 1}}\nthe locals of low: \n{'a': 2, 'b': 1}\n\n\n5\n\n\nWhen keep=True, we can assume the user of delegates would like to make **kwargs visible and use additional keyword args at some point.\nBut when low has no **kwargs, and any additional kwargs (e.g. g=1) introduced will cause lowto throw a TypeError. See example below.\n\ndef low(a:int,   \n        b:int=1, \n       ):\n    print(\"the locals of low: \")\n    pprint(locals())\n    return a + b\n@delegates(low, keep=True)\ndef mid(c:int,   \n        d:int=1, \n        **kwargs \n       ):\n    print(\"the locals of mid: \")\n    pprint(locals())\n    return low(c, **kwargs) + d\n@delegates(mid, keep=True)\ndef high(e:int,   \n         f:int=1, \n         **kwargs \n        ):\n    print(\"the locals of high: \")\n    pprint(locals())\n    return mid(e, **kwargs) + f\n\n\ntry: \n    high(e=2,f=1,d=1,b=1,g=1) # shift + tab to see **kwargs available\nexcept TypeError as e: \n    print(e)\n\nthe locals of high: \n{'e': 2, 'f': 1, 'kwargs': {'b': 1, 'd': 1, 'g': 1}}\nthe locals of mid: \n{'c': 2, 'd': 1, 'kwargs': {'b': 1, 'g': 1}}\nlow() got an unexpected keyword argument 'g'\n\n\nAfter inserting **kwargs into function low, g=1 is happily accepted by low in kwargs.\n\ndef low(a:int, b:int=2, **kwargs): \n    print(\"the locals of low: \")\n    pprint(locals())\n    return a + b\ntest_eq(high(e=2,f=1,d=1,b=1,g=1),5)\n\nthe locals of high: \n{'e': 2, 'f': 1, 'kwargs': {'b': 1, 'd': 1, 'g': 1}}\nthe locals of mid: \n{'c': 2, 'd': 1, 'kwargs': {'b': 1, 'g': 1}}\nthe locals of low: \n{'a': 2, 'b': 1, 'kwargs': {'g': 1}}\n\n\nWouldn’t it be nicer if we can remind or warn the delegates user that low with no **kwargs will cause error when you set keep=True?\n\n\n\nSee below the one of a few examples when fastai uses keep=True I have found on August 11 2022.\nhow-delegates: correct way of using keep=True: pay attention to the first line and last line of the code block below\n@delegates(plt.subplots, keep=True)\ndef subplots(\n    nrows:int=1, # Number of rows in returned axes grid\n    ncols:int=1, # Number of columns in returned axes grid\n    figsize:tuple=None, # Width, height in inches of the returned figure \n    imsize:int=3, # Size (in inches) of images that will be displayed in the returned figure\n    suptitle:str=None, # Title to be set to returned figure\n    **kwargs\n) -> (plt.Figure, plt.Axes): # Returns both fig and ax as a tuple \n    \"Returns a figure and set of subplots to display images of `imsize` inches\"\n    if figsize is None: \n        h=nrows*imsize if suptitle is None or imsize>2 else nrows*imsize+0.6 #https://github.com/matplotlib/matplotlib/issues/5355\n        figsize=(ncols*imsize, h)\n    fig,ax = plt.subplots(nrows, ncols, figsize=figsize, **kwargs) # must have **kwargs here\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n delegates_v1 (to=None, keep=False, but:list=None)\n\nDecorator: replace **kwargs in signature with params from to. If keep=Trueand to has no **kwargs in its signature, a warning of TypeError will be generated.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nto\nNoneType\nNone\ndelegates to to replace **kwargs with its own params\n\n\nkeep\nbool\nFalse\nkeep **kwargs in the signature or not\n\n\nbut\nlist\nNone\nleave out certain params from the signature\n\n\n\n\n\n\ndef low(a:int, b:int=1): pass\n\n@delegates_v1(low, keep=True)\ndef mid(c:int, d:int=1, **kwargs): pass\n\nWarning: adding extra kwargs to mid will cause TypeError to low\n\n\n\n\n@delegates_v1(mid, keep=True)\ndef high(e:int, f:int=1, **kwargs): pass\n\nWarning: adding extra kwargs to high will cause TypeError to low\n\n\n\n\n\n\n\n\nimport fastcore.meta as fm\n\n\ndef low(a, b:int=1): pass\n@fm.delegates(low, keep=True)\ndef mid(c, d:int=1, **kwargs): pass\n\n\ninspect.signature(mid)\n\n<Signature (c, d: int = 1, *, b: int = 1, **kwargs)>\n\n\nThe signature above indicate that b from low is POSITIONAL_OR_KEYWORD kind. However, if you run b as so, it causes a TypeError like below.\n\ntry: \n    mid(1,1,1)\nexcept TypeError as e:\n    print(e)\n\nmid() takes from 1 to 2 positional arguments but 3 were given\n\n\n\n\nb in practice is a KEYWORD_ONLY param but when its type checked it is not.\n\n{p.name: p.kind for p in inspect.signature(mid).parameters.values()}\n\n{'c': <_ParameterKind.POSITIONAL_OR_KEYWORD: 1>,\n 'd': <_ParameterKind.POSITIONAL_OR_KEYWORD: 1>,\n 'b': <_ParameterKind.KEYWORD_ONLY: 3>,\n 'kwargs': <_ParameterKind.VAR_KEYWORD: 4>}\n\n\n\n\n\n\nLet’s make Core.delegates_v2 to print a message for users to use params from to as Keyword only params\n\ns = {'a':1, 'b':2}\n[i for i in s.keys()]\n\n['a', 'b']\n\n\n\n\n\n\n\n delegates_v2 (to=None, keep=False, but:list=None)\n\nCompared with v1, delegates_v2 func add a feature to remind users that params from to are keyword-only params for f.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nto\nNoneType\nNone\ndelegates to to replace **kwargs with its own params\n\n\nkeep\nbool\nFalse\nkeep **kwargs in the signature or not\n\n\nbut\nlist\nNone\nleave out certain params from the signature\n\n\n\n\n\n\ndef low(a, b:int=1): pass\n@delegates_v2(low, keep=True)\ndef mid(c, d:int=1, **kwargs): pass\n@delegates_v2(mid, keep=True)\ndef high(e, f:int=1, **kwargs): pass\n\nmid has ['b'] as keyword only params, not to be used as positional.\nWarning: adding extra kwargs to mid will cause TypeError to low\n\nhigh has ['d', 'b'] as keyword only params, not to be used as positional.\nWarning: adding extra kwargs to high will cause TypeError to low\n\n\n\n\n{p.name: p.kind for p in inspect.signature(mid).parameters.values()}\n\n{'c': <_ParameterKind.POSITIONAL_OR_KEYWORD: 1>,\n 'd': <_ParameterKind.POSITIONAL_OR_KEYWORD: 1>,\n 'b': <_ParameterKind.POSITIONAL_OR_KEYWORD: 1>,\n 'kwargs': <_ParameterKind.VAR_KEYWORD: 4>}\n\n\n\ntry: \n    mid(1,1,1)\nexcept TypeError as e:\n    print(e)\n\nmid() takes from 1 to 2 positional arguments but 3 were given\n\n\n\n\n\n\n\n\n\n\n\n delegates_v3 (to=None, keep=False, but:list=None)\n\nCompared with v1, delegates_v2 func add a feature to remind users that params from to are keyword-only params for f.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nto\nNoneType\nNone\ndelegates to to replace **kwargs with its own params\n\n\nkeep\nbool\nFalse\nkeep **kwargs in the signature or not\n\n\nbut\nlist\nNone\nleave out certain params from the signature\n\n\n\n\n\n\nBy adding a single line of code below the line where s2 occurs.\n# Change type from POSITIONAL_OR_KEYWORD to KEYWORD_ONLY for all parameters in s2\ns2 = {name: param.replace(kind=inspect.Parameter.KEYWORD_ONLY) for name, param in s2.items()} \nWith Jeremy’s help, I have shortened the code by simply modifying the line started with s2=\n\ndef delegates(to=None, keep=False, but=None):\n    \"Decorator: replace `**kwargs` in signature with params from `to`\"\n    if but is None: but = []\n    def _f(f):\n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n        from_f = getattr(from_f,'__func__',from_f)\n        to_f = getattr(to_f,'__func__',to_f)\n        if hasattr(from_f,'__delwrap__'): return f\n        sig = inspect.signature(from_f)\n        sigd = dict(sig.parameters)\n        k = sigd.pop('kwargs')\n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()\n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}\n        sigd.update(s2)\n        if keep: sigd['kwargs'] = k\n        else: from_f.__delwrap__ = to_f\n        from_f.__signature__ = sig.replace(parameters=sigd.values())\n        return f\n    return _f\n\n\ndef low(a, b:int=1): pass\n@delegates(low, keep=True)\ndef mid(c, d:int=1, **kwargs): pass\n@delegates(mid, keep=True)\ndef high(e, f:int=1, **kwargs): pass\n\n\n{p.name: p.kind for p in inspect.signature(mid).parameters.values()}\n\n{'c': <_ParameterKind.POSITIONAL_OR_KEYWORD: 1>,\n 'd': <_ParameterKind.POSITIONAL_OR_KEYWORD: 1>,\n 'b': <_ParameterKind.KEYWORD_ONLY: 3>,\n 'kwargs': <_ParameterKind.VAR_KEYWORD: 4>}\n\n\n\ninspect.signature(mid)\n\n<Signature (c, d: int = 1, *, b: int = 1, **kwargs)>"
  },
  {
    "objectID": "fastcore/previous/fastcoremeta.html#mk_param",
    "href": "fastcore/previous/fastcoremeta.html#mk_param",
    "title": "fastcore_meta",
    "section": "_mk_param",
    "text": "_mk_param\nhow-parameter: How to make a parameter\n\nhow-import: What does from fastcore.meta import * mean\nfrom fastcore.meta import * won’t give you everything inside meta module but a selective group contained in a list __all__, to use the unselected ones, you can:\nimport fastcore.met as fm\nand use fm. + tab to check out everything.\n\n!head /Users/Natsume/mambaforge/lib/python3.9/site-packages/fastcore/meta.py\n\nhead: /Users/Natsume/mambaforge/lib/python3.9/site-packages/fastcore/meta.py: No such file or directory\n\n\n\n\n_mk_param examples\n\nfrom fastcore.meta import _mk_param\n\n\n_mk_param('b'), _mk_param('b', 1)\n\n(<Parameter \"b=None\">, <Parameter \"b=1\">)\n\n\n\n\n_mk_param source\n\ndef _mk_param(n,d=None): return inspect.Parameter(n, inspect.Parameter.KEYWORD_ONLY, default=d)\n\ndef _mk_param(n,d=None): return inspect.Parameter(n, inspect.Parameter.KEYWORD_ONLY, default=d)\n\n\n_mk_param anatomy\n\nhow-inspect: get signature\n\ninspect.signature(inspect.Parameter)\n\n<Signature (name, kind, *, default, annotation)>\n\n\n\n\nhow-inspect: getdoc\n\npprint(inspect.getdoc(inspect.Parameter))\n\n('Represents a parameter in a function signature.\\n'\n '\\n'\n 'Has the following public attributes:\\n'\n '\\n'\n '* name : str\\n'\n '    The name of the parameter as a string.\\n'\n '* default : object\\n'\n '    The default value for the parameter if specified.  If the\\n'\n '    parameter has no default value, this attribute is set to\\n'\n '    `Parameter.empty`.\\n'\n '* annotation\\n'\n '    The annotation for the parameter if specified.  If the\\n'\n '    parameter has no annotation, this attribute is set to\\n'\n '    `Parameter.empty`.\\n'\n '* kind : str\\n'\n '    Describes how argument values are bound to the parameter.\\n'\n '    Possible values: `Parameter.POSITIONAL_ONLY`,\\n'\n '    `Parameter.POSITIONAL_OR_KEYWORD`, `Parameter.VAR_POSITIONAL`,\\n'\n '    `Parameter.KEYWORD_ONLY`, `Parameter.VAR_KEYWORD`.')\n\n\n\n\nhow-inspect: create Parameter\n\np = inspect.Parameter(\"b\", inspect.Parameter.KEYWORD_ONLY, default=None)\ntype(p), p\n\n(inspect.Parameter, <Parameter \"b=None\">)"
  },
  {
    "objectID": "fastcore/previous/fastcoremeta.html#use_kwargs_dict",
    "href": "fastcore/previous/fastcoremeta.html#use_kwargs_dict",
    "title": "fastcore_meta",
    "section": "use_kwargs_dict",
    "text": "use_kwargs_dict\nhow-kwargs: replace **kwargs with a dict of params\n\nuse_kwargs_dic source\n\ndef use_kwargs_dict(keep=False, **kwargs):\n    \"Decorator: replace `**kwargs` in signature with `names` params\"\n    def _f(f):\n        sig = inspect.signature(f)\n        sigd = dict(sig.parameters)\n        k = sigd.pop('kwargs')\n        s2 = {n:_mk_param(n,d) for n,d in kwargs.items() if n not in sigd}\n        sigd.update(s2)\n        if keep: sigd['kwargs'] = k\n        f.__signature__ = sig.replace(parameters=sigd.values())\n        return f\n    return _f\n\n\nhow-code: put for in and if else in a single line\ns2 = {n:_mk_param(n,d) for n,d in kwargs.items() if n not in sigd}\n\n\nmost attributes like __signature__, __func__ are added by decorators\n\ndef foo(a, b=1, **kwargs): pass\nhasattr(foo, '__signature__')\n\nFalse\n\n\n\n@use_kwargs_dict(y=1,z=None)\ndef foo(a, b=1, **kwargs): pass\nhasattr(foo, '__signature__')\n\nTrue\n\n\n\n\n\nuse_kwargs_dict examples\nReplace all **kwargs with named arguments like so:\n\n@use_kwargs_dict(y=1,z=None)\ndef foo(a, b=1, **kwargs): pass\n\ntest_sig(foo, '(a, b=1, *, y=1, z=None)')\n\nAdd named arguments, but optionally keep **kwargs by setting keep=True:\n\n@use_kwargs_dict(y=1,z=None, keep=True)\ndef foo(a, b=1, **kwargs): pass\n\ntest_sig(foo, '(a, b=1, *, y=1, z=None, **kwargs)')"
  },
  {
    "objectID": "fastcore/previous/fastcoremeta.html#use_kwargs",
    "href": "fastcore/previous/fastcoremeta.html#use_kwargs",
    "title": "fastcore_meta",
    "section": "use_kwargs",
    "text": "use_kwargs\nhow-kwargs: to replace **kwargs with a list of param names. use_kwargs\n\nuse_kwargs source\n\ndef use_kwargs(names, keep=False):\n    \"Decorator: replace `**kwargs` in signature with `names` params\"\n    def _f(f):\n        sig = inspect.signature(f)\n        sigd = dict(sig.parameters)\n        k = sigd.pop('kwargs')\n        s2 = {n:_mk_param(n) for n in names if n not in sigd}\n        sigd.update(s2)\n        if keep: sigd['kwargs'] = k\n        f.__signature__ = sig.replace(parameters=sigd.values())\n        return f\n    return _f\n\n\n\nuse_kwargs examples\nuse_kwargs is different than use_kwargs_dict as it only replaces **kwargs with named parameters without any default values:\n\n@use_kwargs(['y', 'z'])\ndef foo(a, b=1, **kwargs): pass\n\ntest_sig(foo, '(a, b=1, *, y=None, z=None)')\ninspect.signature(foo)\n\n<Signature (a, b=1, *, y=None, z=None)>\n\n\n\ntry:\n    foo(1,1,1)\nexcept TypeError as e:\n    print(e)\nassert foo(1,1,y=1) == foo(1,1,y=1,z=None)\n\nfoo() takes from 1 to 2 positional arguments but 3 were given\n\n\nYou may optionally keep the **kwargs argument in your signature by setting keep=True:\n\n@use_kwargs(['y', 'z'], keep=True)\ndef foo(a, *args, b=1, **kwargs): pprint(locals())\ntest_sig(foo, '(a, *args, b=1, y=None, z=None, **kwargs)')\n\n\n\nhow-code: how *args in signature behave?\n\nfoo(1,[1],y=1)\n\n{'a': 1, 'args': ([1],), 'b': 1, 'kwargs': {'y': 1}}\n\n\n\nfoo(1,[1,1],y=1)\n\n{'a': 1, 'args': ([1, 1],), 'b': 1, 'kwargs': {'y': 1}}\n\n\n\nfoo(1,1,1,y=1)\n\n{'a': 1, 'args': (1, 1), 'b': 1, 'kwargs': {'y': 1}}\n\n\n\nfoo(1,1,1,b=1,y=1)\n\n{'a': 1, 'args': (1, 1), 'b': 1, 'kwargs': {'y': 1}}"
  },
  {
    "objectID": "fastcore/previous/fastcoremeta.html#test_sig",
    "href": "fastcore/previous/fastcoremeta.html#test_sig",
    "title": "fastcore_meta",
    "section": "test_sig",
    "text": "test_sig\nhow-test: signature\n\ntest_sig source\n\ndef test_sig(f, b):\n    \"Test the signature of an object\"\n    test_eq(str(inspect.signature(f)), b)\n\n\n\ntest_sig examples\n\ndef func_1(h,i,j): pass\ndef func_2(h,i=3, j=[5,6]): pass\n\nclass T:\n    def __init__(self, a, b): pass\n\ntest_sig(func_1, '(h, i, j)')\ntest_sig(func_2, '(h, i=3, j=[5, 6])')\ntest_sig(T, '(a, b)')\n\n\n\ntest_sig anatomy\n\ninspect.signature(T)\n\n<Signature (a, b)>\n\n\n\nhow-str: turn signature into string\n\nstr(inspect.signature(T))\n\n'(a, b)'\n\n\n\ninspect.signature(func_2)\n\n<Signature (h, i=3, j=[5, 6])>\n\n\n\nstr(inspect.signature(func_2))\n\n'(h, i=3, j=[5, 6])'\n\n\n\ntest_eq(str(inspect.signature(func_2)), '(h, i=3, j=[5, 6])')\n\n\nassert str(inspect.signature(func_2)) == '(h, i=3, j=[5, 6])'"
  },
  {
    "objectID": "fastcore/previous/fastcoremeta.html#rm_self",
    "href": "fastcore/previous/fastcoremeta.html#rm_self",
    "title": "fastcore_meta",
    "section": "_rm_self",
    "text": "_rm_self\nhow-inspect/how-self: remove self in signature\n\n_rm_self source\n\ndef _rm_self(sig):\n    sigd = dict(sig.parameters)\n    sigd.pop('self')\n    return sig.replace(parameters=sigd.values())\n\n\n\n_rm_self examples\n\nclass Base:\n    def __init__(self, a, b:int=1, **kwargs): pass\n    def test(self, c, d): pass\n\n\ninspect.signature(Base.__init__)\n\n<Signature (self, a, b: int = 1, **kwargs)>\n\n\n\n_rm_self(inspect.signature(Base.__init__))\n\n<Signature (a, b: int = 1, **kwargs)>\n\n\n\ninspect.signature(Base.test)\n\n<Signature (self, c, d)>\n\n\n\n_rm_self(inspect.signature(Base.test))\n\n<Signature (c, d)>\n\n\n\n\n_rm_self anatomy\n\nsig = inspect.signature(Base.__init__)\nsig\n\n<Signature (self, a, b: int = 1, **kwargs)>\n\n\n\nsigd = dict(sig.parameters)\nsigd\n\n{'self': <Parameter \"self\">,\n 'a': <Parameter \"a\">,\n 'b': <Parameter \"b: int = 1\">,\n 'kwargs': <Parameter \"**kwargs\">}\n\n\n\nsigd.pop('self')\nsigd\n\n{'a': <Parameter \"a\">,\n 'b': <Parameter \"b: int = 1\">,\n 'kwargs': <Parameter \"**kwargs\">}\n\n\n\nsigd.values()\n\ndict_values([<Parameter \"a\">, <Parameter \"b: int = 1\">, <Parameter \"**kwargs\">])\n\n\n\nsig.replace(parameters=sigd.values())\n\n<Signature (a, b: int = 1, **kwargs)>"
  },
  {
    "objectID": "fastcore/previous/fastcoremeta.html#fixsigmeta",
    "href": "fastcore/previous/fastcoremeta.html#fixsigmeta",
    "title": "fastcore_meta",
    "section": "FixSigMeta",
    "text": "FixSigMeta\nA metaclass that fixes the signature on classes that override __new__\nWhen you inherit from a class that defines __new__, or a metaclass that defines __call__, the signature of your __init__ method is obfuscated such that tab completion no longer works. FixSigMeta fixes this issue and restores signatures.\nTo understand what FixSigMeta does, it is useful to inspect an object’s signature. You can inspect the signature of an object with inspect.signature:\nInteresting! FixSigMeta?? won’t give us the source code, neither can inspect.getsource on it.\n\nFixSigMeta examples\n\nexamples not really working effectively\n\nclass T:\n    def __init__(self, a, b, c): pass\n    \ninspect.signature(T)\n\n<Signature (a, b, c)>\n\n\nThis corresponds to tab completion working in the normal way:\nT() + shift + tab can provide the following info on the function\nInit signature: T(a, b, c)\nDocstring:      <no docstring>\nType:           type\nWhat is the signature of T.__init__\nHowever, when you inherhit from a class that defines __new__ or a metaclass that defines __call__ this obfuscates the signature by overriding your class with the signature of __new__, which prevents tab completion from displaying useful information:\n\nclass Foo:\n    def __new__(self, **args): pass\n    \nclass Bar(Foo):\n    def __init__(self, d, e, f): pass\n\n\npprint(inspect.signature(Foo))\npprint(inspect.signature(Foo.__new__))\n\n<Signature (**args)>\n<Signature (self, **args)>\n\n\n\npprint(inspect.signature(Bar))\npprint(inspect.signature(Bar.__new__))\npprint(inspect.signature(Bar.__init__))\n\n<Signature (d, e, f)>\n<Signature (self, **args)>\n<Signature (self, d, e, f)>\n\n\nFinally, the signature and tab completion can be restored by inheriting from the metaclass FixSigMeta as shown below:\n\n\nhow-FixSigMeta: when inherit a class override __new__\n\n\n\n\nFixSigMeta\n\n FixSigMeta (name, bases, dict)\n\nA metaclass that fixes the signature on classes that override __new__ of type\n\nclass Foo:\n    def __new__(cls, *args): # to create an instance of class Foo\n        print(\"============================\\nRunning Foo.__new__\")\n        \n        print(f\"local variables inside Foo.__new__:\\n\")\n        pprint(locals())\n        print(f\"cls.__class__ is: {cls.__class__}\")\n        \n        print(\"\\nwhat is super():\\n\")\n        pprint(super())\n        res = super().__new__(cls) # equivalent to object.__new__(cls), \n        # it is to create an object of class Bar whose superclass is Foo\n        print(f\"super().__new__ created: {res}\\n\")\n\n        return res\n    \n# FixSigMeta is called here to create Bar class, not to create instance of Bar\nclass Bar(Foo, metaclass=FixSigMeta): \n    # running Foo.__new__ here\n    print(f\"=================================We are in the context of Bar: \\n\")\n    \n    def __init__(self, d, e, f): \n        print(\"\\n==================================\\n we are inside Bar.__init__\")\n        print(f\"local variables available to Bar.__init__:\\n\")\n        pprint(locals())\n\n=================================We are in the context of Bar: \n\n============================\nrunning metaclass FixSigMeta.__new__\n\nlocal variables are:\n\n{'__class__': <class '__main__.FixSigMeta'>,\n 'bases': (<class '__main__.Foo'>,),\n 'cls': <class '__main__.FixSigMeta'>,\n 'dict': {'__init__': <function Bar.__init__>,\n          '__module__': '__main__',\n          '__qualname__': 'Bar'},\n 'name': 'Bar'}\n\nUsing type.__new__ to create a class instance of type: <class '__main__.Bar'>\n\"Bar's type should and is: <class '__main__.FixSigMeta'>\"\n\nBar's inheritance tree: (<class '__main__.Bar'>, <class '__main__.Foo'>, <class 'object'>)\nIn other words, Bar's bases are: (<class '__main__.Foo'>,)\n\n\ndoes Bar have attr `__signature__`:False\n<Signature (d, e, f)>\nif Bar has its own __init__, then update with __init__'s signature\n\nnow, Bar.__signature__ becomes:(d, e, f)\n\nend of metaclass FixSigMeta.__new__\n============================\n\n\n\ntest_eq(isinstance(Bar, FixSigMeta), True) # FixSigMeta created Bar\ntest_eq(isinstance(Bar, Foo), False) \ntest_eq(issubclass(Bar, Foo), True) # Bar inherited from Foo\ntest_eq(issubclass(Foo, object), True)\n\n\n# When creating an instance of Bar\n# It will not run FixSigMeta.__new__, but run FixSigMeta.__call__ (not specified) \n# as a result, inside Bar it inherits and runs Foo.__new__, \n# and then inherits and overrides Foo.__init__ with Bar.__init__\nb = Bar(1,2,3)\n\n============================\nRunning Foo.__new__\nlocal variables inside Foo.__new__:\n\n{'__class__': <class '__main__.Foo'>,\n 'args': (1, 2, 3),\n 'cls': <class '__main__.Bar'>}\ncls.__class__ is: <class '__main__.FixSigMeta'>\n\nwhat is super():\n\n<super: <class 'Foo'>, <Bar object>>\nsuper().__new__ created: <__main__.Bar object>\n\n\n==================================\n we are inside Bar.__init__\nlocal variables available to Bar.__init__:\n\n{'d': 1, 'e': 2, 'f': 3, 'self': <__main__.Bar object>}\n\n\n\nhow-FixSigMeta: when inherit a metaclass to override __call__\nIf you need to define a metaclass that overrides __call__ (as done in PrePostInitMeta), you need to inherit from FixSigMeta instead of type when constructing the metaclass to preserve the signature in __init__. Be careful not to override __new__ when doing this:\n\nclass TestMeta(FixSigMeta): # making a subclass of FixSigMeta, which overrides __call__\n    # __new__ comes from FixSigMeta\n    def __call__(cls, *args, **kwargs): pass\n\n\nclass T(metaclass=TestMeta):\n    def __init__(self, a, b): pass\n\n============================\nrunning metaclass FixSigMeta.__new__\n\nlocal variables are:\n\n{'__class__': <class '__main__.FixSigMeta'>,\n 'bases': (),\n 'cls': <class '__main__.TestMeta'>,\n 'dict': {'__init__': <function T.__init__>,\n          '__module__': '__main__',\n          '__qualname__': 'T'},\n 'name': 'T'}\n\nUsing type.__new__ to create a class instance of type: <class '__main__.T'>\n\"T's type should and is: <class '__main__.TestMeta'>\"\n\nT's inheritance tree: (<class '__main__.T'>, <class 'object'>)\nIn other words, T's bases are: (<class 'object'>,)\n\n\ndoes T have attr `__signature__`:False\n<Signature (*args, **kwargs)>\nif T has its own __init__, then update with __init__'s signature\n\nnow, T.__signature__ becomes:(a, b)\n\nend of metaclass FixSigMeta.__new__\n============================\n\n\n\ntest_sig(T, '(a, b)')\n\nOn the other hand, if you fail to inherit from FixSigMeta when inheriting from a metaclass that overrides __call__, your signature will reflect that of __call__ instead (which is often undesirable):\n\nclass GenericMeta(type): # create a metaclass from type and overrides both __new__ and __call_\n    \"A boilerplate metaclass that doesn't do anything for testing.\"\n    \n    def __new__(cls, name, bases, dict):\n        print(\"============================\\nrunning metaclass GenericMeta.__new__\\n\")\n        print(f\"local variables available to GenericMeta.__new__:\\n\")\n        pprint(locals())\n        \n        res = super().__new__(cls, name, bases, dict) # run type.__new__()\n        print(f\"\\ntype.__new__ created: {res}\")\n        pprint(f\"{res.__name__}'s type is {type(res)}\")\n        print(f\"\\n{res.__name__}'s inheritance tree: {res.__mro__}\")\n        print(f\"\\ndoes {res.__name__} have attr `__signature__`:{hasattr(res, '__signature__')}\")\n        pprint(inspect.signature(res))\n        print(f\"{res.__name__}'s bases are: {res.__bases__}\\n\")\n        \n        return res\n    \n    def __call__(cls, *args, **kwargs): print(\"==========================\\nrunning GenericMeta.__call__\")\n\n\nclass T2(metaclass=GenericMeta):\n    def __init__(self, a, b): pass\n\n============================\nrunning metaclass GenericMeta.__new__\n\nlocal variables available to GenericMeta.__new__:\n\n{'__class__': <class '__main__.GenericMeta'>,\n 'bases': (),\n 'cls': <class '__main__.GenericMeta'>,\n 'dict': {'__init__': <function T2.__init__>,\n          '__module__': '__main__',\n          '__qualname__': 'T2'},\n 'name': 'T2'}\n\ntype.__new__ created: <class '__main__.T2'>\n\"T2's type is <class '__main__.GenericMeta'>\"\n\nT2's inheritance tree: (<class '__main__.T2'>, <class 'object'>)\n\ndoes T2 have attr `__signature__`:False\n<Signature (*args, **kwargs)>\nT2's bases are: (<class 'object'>,)\n\n\n\n\nT2() # to instantiate an object of T2 class, GenericMeta.__call__ is called under the scene\n\n==========================\nrunning GenericMeta.__call__\n\n\n\nclass GenericMeta(FixSigMeta): # make GenericMeta a subclass of metaclass FixSigMeta\n    \"A boilerplate metaclass that doesn't do anything for testing.\"\n    def __new__(cls, name, bases, dict):\n        print(\"============================\\nrunning metaclass GenericMeta.__new__\\n\")\n        print(f\"local variables available to GenericMeta.__new__:\\n\")\n        pprint(locals())\n        \n        res = super().__new__(cls, name, bases, dict) # run type.__new__()\n        print(f\"\\ntype.__new__ created: {res}\")\n        pprint(f\"{res.__name__}'s type is {type(res)}\")\n        print(f\"\\n{res.__name__}'s inheritance tree: {res.__mro__}\")\n        print(f\"\\ndoes {res.__name__} have attr `__signature__`:{hasattr(res, '__signature__')}\")\n        pprint(inspect.signature(res))\n        print(f\"{res.__name__}'s bases are: {res.__bases__}\\n\")\n        \n        return res\n    \n    \n    def __call__(cls, *args, **kwargs): print(\"==========================\\nrunning GenericMeta.__call__\")\n\nclass T2(metaclass=GenericMeta): # create T2 class as an instance of GenericMeta class\n    def __init__(self, a, b): pass\n\ntest_sig(T2, '(a, b)')\n\n============================\nrunning metaclass GenericMeta.__new__\n\nlocal variables available to GenericMeta.__new__:\n\n{'__class__': <class '__main__.GenericMeta'>,\n 'bases': (),\n 'cls': <class '__main__.GenericMeta'>,\n 'dict': {'__init__': <function T2.__init__>,\n          '__module__': '__main__',\n          '__qualname__': 'T2'},\n 'name': 'T2'}\n============================\nrunning metaclass FixSigMeta.__new__\n\nlocal variables are:\n\n{'__class__': <class '__main__.FixSigMeta'>,\n 'bases': (),\n 'cls': <class '__main__.GenericMeta'>,\n 'dict': {'__init__': <function T2.__init__>,\n          '__module__': '__main__',\n          '__qualname__': 'T2'},\n 'name': 'T2'}\n\nUsing type.__new__ to create a class instance of type: <class '__main__.T2'>\n\"T2's type should and is: <class '__main__.GenericMeta'>\"\n\nT2's inheritance tree: (<class '__main__.T2'>, <class 'object'>)\nIn other words, T2's bases are: (<class 'object'>,)\n\n\ndoes T2 have attr `__signature__`:False\n<Signature (*args, **kwargs)>\nif T2 has its own __init__, then update with __init__'s signature\n\nnow, T2.__signature__ becomes:(a, b)\n\nend of metaclass FixSigMeta.__new__\n============================\n\ntype.__new__ created: <class '__main__.T2'>\n\"T2's type is <class '__main__.GenericMeta'>\"\n\nT2's inheritance tree: (<class '__main__.T2'>, <class 'object'>)\n\ndoes T2 have attr `__signature__`:True\n<Signature (a, b)>\nT2's bases are: (<class 'object'>,)\n\n\n\n\nFixSigMeta??"
  },
  {
    "objectID": "fastcore/previous/fastcoremeta.html#prepostinitmeta",
    "href": "fastcore/previous/fastcoremeta.html#prepostinitmeta",
    "title": "fastcore_meta",
    "section": "PrePostInitMeta",
    "text": "PrePostInitMeta\n\nRelations between PrePostInitMeta and FixSigMeta\n\n\n\nPrePostInitMeta\n\n PrePostInitMeta (name, bases, dict)\n\nA metaclass that calls optional __pre_init__ and __post_init__ methods\n\ntype(PrePostInitMeta) == PrePostInitMeta.__class__ == type\n\nTrue\n\n\n\nPrePostInitMeta.__bases__ # so will inherit __new__, __init__ from FixSigMeta\n\n(__main__.FixSigMeta,)\n\n\n\nPrePostInitMeta.__mro__\n\n(__main__.PrePostInitMeta, __main__.FixSigMeta, type, object)\n\n\n\nFixSigMeta.__mro__\n\n(__main__.FixSigMeta, type, object)\n\n\n\n\nPrePostInitMeta examples\nA metaclass that calls optional __pre_init__ and __post_init__ methods __pre_init__ and __post_init__ are useful for initializing variables or performing tasks prior to or after __init__ being called, respectively. Fore example:\n\n# When creating an instance class by metaclass PrePostInitMeta, \n# PrePostInitMeta.__new__ is called, but PrePostInitMeta inherit __new__ from FixSigMeta\n# so FixSigMeta.__new__ is actually called below\n\n# _T is inherited from object and will use object.__new__ and object.__init__ \n# _T needs to create its own instance objects\n\n# _T builts its own 3 instance methods which all related to __init__\n\n# todo: export my debugging version of FixSigMeta to the library\n# todo: maybe the first problem of delegates do need attention\nclass _T(metaclass=PrePostInitMeta):\n    print(\"\\n===============Running inside _T\\n\")\n    def __pre_init__(self):  \n        print(\"====Running inside _T.__pre_init__\\n\")\n        self.a  = 0; \n    def __init__(self,b=0):  \n        self.b = self.a + 1; assert self.b==1\n        print(\"====Running inside _T.__init__\\n\")\n    def __post_init__(self): \n        self.c = self.b + 2; assert self.c==3\n        print(\"====Running inside _T.__post_init__\\n\")\n\n\n===============Running inside _T\n\n============================\nrunning metaclass FixSigMeta.__new__\n\nlocal variables are:\n\n{'__class__': <class '__main__.FixSigMeta'>,\n 'bases': (),\n 'cls': <class '__main__.PrePostInitMeta'>,\n 'dict': {'__init__': <function _T.__init__>,\n          '__module__': '__main__',\n          '__post_init__': <function _T.__post_init__>,\n          '__pre_init__': <function _T.__pre_init__>,\n          '__qualname__': '_T'},\n 'name': '_T'}\n\nUsing type.__new__ to create a class instance of type: <class '__main__._T'>\n\"_T's type should and is: <class '__main__.PrePostInitMeta'>\"\n\n_T's inheritance tree: (<class '__main__._T'>, <class 'object'>)\nIn other words, _T's bases are: (<class 'object'>,)\n\n\ndoes _T have attr `__signature__`:False\n<Signature (*args, **kwargs)>\nif _T has its own __init__, then update with __init__'s signature\n\nnow, _T.__signature__ becomes:(b=0)\n\nend of metaclass FixSigMeta.__new__\n============================\n\n\n\n# when _T is instantiated, _T's metaclass'__call__ (i.e., PrePostInitMeta.__call__) is called \n# _T.__class__.__call__ in general will use _T.__new__ and _T.__init__ \n# to create and initialize an instance object of _T.\n\n# PrePostInitMeta.__call__: has a particular way of creating and initializing an object\n# using _T.__new__, _T.__init__, and _T.__pre_init__, _T.__post_init__ \n\nt = _T() # only instantiate an object, to do so, PrePostInitMeta.__call__ is called\n\n==================\nRunning PrePostInitMeta.__call__\n\nlocal variables:\n{'args': (), 'cls': <class '__main__._T'>, 'kwargs': {}}\n\nTask 1 running res = _T.__new__(cls) to create an obj instance of _T: <__main__._T object>\n\nTask 2: \nif _T object is an instance of _T and _T has '__pre_init__' attr, then run _T.__pre_init__ on the object.\n====Running inside _T.__pre_init__\n\n\nTask 3: \nif _T object is an instance of _T, then run _T.__init__ on the object.\n====Running inside _T.__init__\n\n\nTask 4: \nif _T object is an instance of _T and _T has '__post_init__' attr, then run _T.__post_init__ on the object.\n====Running inside _T.__post_init__\n\n\nfinally, return the initialized object of class _T\n====================end of PrePostInitMeta.__call__\n\n\n\ntest_eq(t.a, 0) # set with __pre_init__\ntest_eq(t.b, 1) # set with __init__\ntest_eq(t.c, 3) # set with __post_init__\n\nhow-prepostinitmeta: One use for PrePostInitMeta is avoiding the super().__init__() boilerplate associated with subclassing, such as used in AutoInit."
  },
  {
    "objectID": "fastcore/previous/fastcoremeta.html#autoinit",
    "href": "fastcore/previous/fastcoremeta.html#autoinit",
    "title": "fastcore_meta",
    "section": "AutoInit",
    "text": "AutoInit\nhow-super: a good answer on super and a great guide? and see PrePostInitMeta and AutoInit make it even better!\n\nAutoInit source\n\n\n\nAutoInit\n\n AutoInit (*args, **kwargs)\n\nSame as object, but no need for subclasses to call super().__init__\n\n\nAutoInit examples\nhow-prepostinitmeta: in fastai code\nhow-autoinit: use AutoInit in real life. This is normally used as a mixin, eg:\n\nclass TestParent():\n    def __init__(self): self.h = 10\n        \nclass TestChild(AutoInit, TestParent): # how AutoInit used as mixin\n    print(f\"============Running inside TestChild class:\\n\")\n    def __init__(self): \n        self.k = self.h + 2 # No More worry about super().__init__ \n        print(f\"====running TestChild.__init__\\n\")\n\n============Running inside TestChild class:\n\n============================\nrunning metaclass FixSigMeta.__new__\n\nlocal variables are:\n\n{'__class__': <class '__main__.FixSigMeta'>,\n 'bases': (<class '__main__.AutoInit'>, <class '__main__.TestParent'>),\n 'cls': <class '__main__.PrePostInitMeta'>,\n 'dict': {'__init__': <function TestChild.__init__>,\n          '__module__': '__main__',\n          '__qualname__': 'TestChild'},\n 'name': 'TestChild'}\n\nUsing type.__new__ to create a class instance of type: <class '__main__.TestChild'>\n\"TestChild's type should and is: <class '__main__.PrePostInitMeta'>\"\n\nTestChild's inheritance tree: (<class '__main__.TestChild'>, <class '__main__.AutoInit'>, <class '__main__.TestParent'>, <class 'object'>)\nIn other words, TestChild's bases are: (<class '__main__.AutoInit'>, <class '__main__.TestParent'>)\n\n\ndoes TestChild have attr `__signature__`:False\n<Signature (*args, **kwargs)>\nif TestChild has its own __init__, then update with __init__'s signature\n\nnow, TestChild.__signature__ becomes:()\n\nend of metaclass FixSigMeta.__new__\n============================\n\n\n\nt = TestChild()\ntest_eq(t.h, 10) # h=10 is initialized in the parent class\ntest_eq(t.k, 12)\n\n==================\nRunning PrePostInitMeta.__call__\n\nlocal variables:\n{'args': (), 'cls': <class '__main__.TestChild'>, 'kwargs': {}}\n\nTask 1 running res = TestChild.__new__(cls) to create an obj instance of TestChild: <__main__.TestChild object>\n\nTask 2: \nif TestChild object is an instance of TestChild and TestChild has '__pre_init__' attr, then run TestChild.__pre_init__ on the object.\n\n====Running inside AutoInit.__pre_init__: \n\nNow, object.__init__ is called to initialize, so that subclasses of AutoInit         not need to run this line of code.\n\nTask 3: \nif TestChild object is an instance of TestChild, then run TestChild.__init__ on the object.\n====running TestChild.__init__\n\n\nTask 4: \nif TestChild object is an instance of TestChild and TestChild has '__post_init__' attr, then run TestChild.__post_init__ on the object.\n\nfinally, return the initialized object of class TestChild\n====================end of PrePostInitMeta.__call__\n\n\nhow-class: how-metaclass: a great answer on class and on metaclass"
  },
  {
    "objectID": "fastcore/previous/fastcoremeta.html#section-9",
    "href": "fastcore/previous/fastcoremeta.html#section-9",
    "title": "fastcore_meta",
    "section": "",
    "text": "!jupyter nbconvert --config /Users/Natsume/Documents/mynbcfg.py --to markdown \\\n--output-dir /Users/Natsume/Documents/divefastai/Debuggable/nbconvert\n\n[NbConvertApp] Converting notebook /Users/Natsume/Documents/debuggable/index.ipynb to markdown\n[NbConvertApp] Writing 7680 bytes to /Users/Natsume/Documents/divefastai/Debuggable/nbconvert/index.md\n[NbConvertApp] Converting notebook /Users/Natsume/Documents/debuggable/utils.ipynb to markdown\n[NbConvertApp] Writing 14526 bytes to /Users/Natsume/Documents/divefastai/Debuggable/nbconvert/utils.md\n[NbConvertApp] Converting notebook /Users/Natsume/Documents/debuggable/fastcore/delegates_keep.ipynb to markdown\n[NbConvertApp] Writing 11469 bytes to /Users/Natsume/Documents/divefastai/Debuggable/nbconvert/delegates_keep.md\n[NbConvertApp] Converting notebook /Users/Natsume/Documents/debuggable/fastcore/00_delegates.ipynb to markdown\n[NbConvertApp] Writing 69707 bytes to /Users/Natsume/Documents/divefastai/Debuggable/nbconvert/00_delegates.md\n[NbConvertApp] Converting notebook /Users/Natsume/Documents/debuggable/fastcore/classes_metaclasses.ipynb to markdown\n[NbConvertApp] Writing 27393 bytes to /Users/Natsume/Documents/divefastai/Debuggable/nbconvert/classes_metaclasses.md"
  },
  {
    "objectID": "fastcore/meta/02_use_kwargs_dict.html",
    "href": "fastcore/meta/02_use_kwargs_dict.html",
    "title": "fastcore.meta.use_kwargs_dict",
    "section": "",
    "text": "from fastcore.imports import *\nfrom fastcore.meta import *\nfrom fastcore.test import *\nimport inspect\nfrom debuggable.utils import dbprint, defaults, whichversion, defaults\nfrom pprint import pprint\nimport ast\nfrom datetime import date"
  },
  {
    "objectID": "fastcore/meta/02_use_kwargs_dict.html#source",
    "href": "fastcore/meta/02_use_kwargs_dict.html#source",
    "title": "fastcore.meta.use_kwargs_dict",
    "section": "Source",
    "text": "Source\n\nuse_kwargs_dict??\n\n\ndef use_kwargs_dict(keep=False, **kwargs):\n    \"Decorator: replace `**kwargs` in signature with `names` params\" \n    \"Replacing a signature's `**kwargs` with parameters created with a dictionary\\\n    like {name1:value1, name2:value2}.\"\n    \n    # What is a decorator? it's a func which defines another func _f and then return _f.\n    # What is special about the _f func? it's a func which modifies another func f and return f\n    def _f(f):\n        \n        # get the signature of function f, and assign it to sig\n        dbprint(\"sig = inspect.signature(f)\", \"f\", \"inspect.signature(f)\", \"sig = inspect.signature(f)\", f=f, inspect=inspect)\n        sig = inspect.signature(f)\n        \n        # get all the parameters of sig, and turn them into a dictionary\n        dbprint(\"sigd = dict(sig.parameters)\", \"sig.parameters\", \"dict(sig.parameters)\", \"sigd = dict(sig.parameters)\", sig=sig)\n        sigd = dict(sig.parameters)\n        \n        # remove/pop the item with key `kwargs` out of the dictionary sigd\n        dbprint(\"k = sigd.pop('kwargs')\", \"sigd\", \"k = sigd.pop('kwargs')\", \"sigd\", \"sigd['kwargs'] = k\", sigd=sigd)\n        k = sigd.pop('kwargs')\n        \n        # Openning the input dictionary **kwargs, create a new dictionary s2 to store params created based on the dict kwargs\n        dbprint(\"s2 = {n:_mk_param(n,d) for n,d in kwargs.items() if n not in sigd}\", \"kwargs\", \"sigd\", \\\n                \"for n,d in kwargs.items():\\n    print(f'n: {n}, d: {d}')\\n    if n not in sigd:\\n        print(f'{n}: {_mk_param(n,d)}')\",\\\n                \"s2 = {n:_mk_param(n,d) for n,d in kwargs.items() if n not in sigd}\", kwargs=kwargs, _mk_param=_mk_param)\n        s2 = {n:_mk_param(n,d) for n,d in kwargs.items() if n not in sigd}\n \n        dbprint(\"sigd.update(s2)\", \"s2\", \"sigd.update(s2)\", s2=s2)\n        sigd.update(s2)\n        \n        if keep: sigd['kwargs'] = k\n        f.__signature__ = sig.replace(parameters=sigd.values())\n        return f\n    return _f\n\n\nfrom fastcore.meta import use_kwargs_dict as ukd\ndefaults.src = inspect.getsource(ukd)\ndefaults.deb = inspect.getsource(use_kwargs_dict)\ndefaults.checksource()"
  },
  {
    "objectID": "fastcore/meta/02_use_kwargs_dict.html#example",
    "href": "fastcore/meta/02_use_kwargs_dict.html#example",
    "title": "fastcore.meta.use_kwargs_dict",
    "section": "Example",
    "text": "Example"
  },
  {
    "objectID": "fastcore/meta/00_delegates.html",
    "href": "fastcore/meta/00_delegates.html",
    "title": "fastcore.meta.delegates",
    "section": "",
    "text": "from debuggable.utils import dbprint, defaults, whichversion, defaults, colorize, insert2debug, dbsrclines, checksrc, matchsrcorder\n\n\n# !pip install -U fastcore\nwhichversion('fastcore')\n\nfastcore: 1.5.22 \nPython supercharged for fastai development    \nJeremy Howard and Sylvain Gugger \nhttps://github.com/fastai/fastcore/     \npython_version: >=3.7     \n/Users/Natsume/mambaforge/lib/python3.9/site-packages/fastcore\n\n\n\nfrom fastcore.imports import *\nfrom fastcore.meta import *\nfrom fastcore.test import *\nimport inspect\nfrom pprint import pprint\nfrom datetime import date\nimport ast\nimport pickle\n\n\ntoday = date.today()\nprint(\"Today's date:\", today)\n\nToday's date: 2022-08-27\n\n\n\n\n\nsrcname = \"delegates\""
  },
  {
    "objectID": "fastcore/meta/00_delegates.html#upate-my-source",
    "href": "fastcore/meta/00_delegates.html#upate-my-source",
    "title": "fastcore.meta.delegates",
    "section": "Upate my source",
    "text": "Upate my source\n\n# don't run this cell when just getting started\nwith open(\"db/delegatesdb\", \"rb\") as fp:   # Unpickling\n  defaults.src2dbp.delegatesdb = pickle.load(fp)\n\n\nif defaults.src2dbp.delegatesdb == None:\n    print(\"there is no debuggable source code yet, free to write it from the first line now.\")\nelse:\n    checksrc(srcname)\n\ndef delegates(to:FunctionType=None, # Delegatee                                                                                                              \n              keep=False, # Keep `kwargs` in decorated function?                                                                                             \n              but:list=None): # Exclude these parameters from signature                                                                                      \n    \"Decorator: replace `**kwargs` in signature with params from `to`\"                                                                                       \n    if but is None: but = []                                                                                                                                 \n    def _f(f):                                                                                                                                               \n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__                                                                                          \n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f                                                                            \n        from_f = getattr(from_f,'__func__',from_f)                                                                                                           \n        to_f = getattr(to_f,'__func__',to_f)                                                                                                                 \n        if hasattr(from_f,'__delwrap__'): return f                                                                                                           \n        sig = inspect.signature(from_f)                                                                                                                      \n        sigd = dict(sig.parameters)                                                                                                                          \n        k = sigd.pop('kwargs')                                                                                                                               \n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()                                         \n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}                                                                    \n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}                                                               \n        sigd.update(s2)                                                                                                                                      \n        if keep: sigd['kwargs'] = k                                                                                                                          \n        else: from_f.__delwrap__ = to_f                                                                                                                      \n        from_f.__signature__ = sig.replace(parameters=sigd.values())                                                                                         \n        if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)                                                                           \n        return f                                                                                                                                             \n    return _f"
  },
  {
    "objectID": "fastcore/meta/00_delegates.html#a-personal-docs-on-delegates",
    "href": "fastcore/meta/00_delegates.html#a-personal-docs-on-delegates",
    "title": "fastcore.meta.delegates",
    "section": "A personal docs on delegates",
    "text": "A personal docs on delegates\nI have been developing a workflow of creating my own docs for fastcore. Here is what I have so far.\n1st step: read and run examples from the official docs to understand how you should use it.\n2nd step: write your own examples to test your understanding of the usages and explore the boundaries to cause errors.\n3rd step: read the source and find out what from the source caused the errors using debugging tools like print, pdb.set_trace, %debug, jupyterlab’s visual debugger etc.\nTo keep my docs here readable, I will only present the second step and one or two examples of the third step.\n\npprint(inspect.getsource(delegates))\n\n('def delegates(to:FunctionType=None, # Delegatee\\n'\n '              keep=False, # Keep `kwargs` in decorated function?\\n'\n '              but:list=None): # Exclude these parameters from signature\\n'\n '    \"Decorator: replace `**kwargs` in signature with params from `to`\"\\n'\n '    if but is None: but = []\\n'\n '    def _f(f):\\n'\n '        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\\n'\n '        else:          to_f,from_f = to.__init__ if isinstance(to,type) else '\n 'to,f\\n'\n \"        from_f = getattr(from_f,'__func__',from_f)\\n\"\n \"        to_f = getattr(to_f,'__func__',to_f)\\n\"\n \"        if hasattr(from_f,'__delwrap__'): return f\\n\"\n '        sig = inspect.signature(from_f)\\n'\n '        sigd = dict(sig.parameters)\\n'\n \"        k = sigd.pop('kwargs')\\n\"\n '        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in '\n 'inspect.signature(to_f).parameters.items()\\n'\n '              if v.default != inspect.Parameter.empty and k not in sigd and '\n 'k not in but}\\n'\n '        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd '\n 'and k not in but}\\n'\n '        sigd.update(s2)\\n'\n \"        if keep: sigd['kwargs'] = k\\n\"\n '        else: from_f.__delwrap__ = to_f\\n'\n '        from_f.__signature__ = sig.replace(parameters=sigd.values())\\n'\n \"        if hasattr(from_f, '__annotations__'): \"\n 'from_f.__annotations__.update(anno)\\n'\n '        return f\\n'\n '    return _f\\n')\n\n\n\nWhen to use it?\nWhen f want to replace its **kwargs param with unique kwargs (with their annotations) from to.\n\n\nWho are to and f?\nThey can be functions, instance methods, classmethods, and even classes.\n\n\nWhat is **kwargs?\nIt’s a param of f, to receive unknown keyword args (i.e., not sure how many and what they are) with values. In general, to can tell us what those unkown keyword args for f.\n\n\nAdditional features with keep and but\n\nWhen to use keep=False?\nf is happy with all the params it got, no more expectation of other kwargs, so remove **kwargs from its signature.\n\n\nwhen to use keep=True?\nf is not content with all the params it got, and still expect other kwargs in the future when needed.\n\n\nwhen to use but=['d']?\nf does not want a list of specified kwargs from to, such as d here.\n\n\n\nCreating your own examples to test the boundary of usages\n\ndef low(a, b=1, c=1, **kwargs): pass # to receive unexpected kwargs, `to` need `**kwargs` too.\n@delegates(low, keep=True, but=['b'])\ndef mid(a, d=1, **kwargs): pass\ntest_sig(mid, '(a, d=1, *, c=1, **kwargs)')\nmid(a=1, d=1, c=1, e=1) # mid is open to other unexpected kwargs without error\n\n\ndef low(a, b=1): pass \n@delegates(low) # to as func\ndef mid(c, d=1, **kwargs): pass # f as func\ntest_sig(mid, '(c, d=1, *, b=1)')\n\n\nclass Foo():\n\n    @delegates(low) # to as func\n    @classmethod # classmethod() run before delegates()\n    def clsmid1(cls, c, d=1, **kwargs): pass # f as classmethod\n\n\n    @delegates(clsmid1) # to as classmethod\n    @classmethod\n    def clsmid2(cls, c, e=1, **kwargs): pass # f as classmethod\n\ntest_sig(Foo.clsmid1, '(c, d=1, *, b=1)')\ntest_sig(Foo.clsmid2, '(c, e=1, *, d=1, b=1)')\n\n\nclass Foo():\n    \n    @classmethod\n    @delegates(low) # to as func\n    def clsmid1(cls, c, d=1, **kwargs): pass # f as func, not classmethod\n\n    @classmethod \n    @delegates(clsmid1)  # to as classmethod \n    def clsmid2(cls, c, e=1, **kwargs): pass # f as func, not classmethod\n\ntest_sig(Foo.clsmid1, '(c, d=1, *, b=1)')\ntest_sig(Foo.clsmid2, '(c, e=1, *, d=1, b=1)')\n\n\nclass Foo1():\n\n    @delegates(Foo.clsmid2) # to as classmethod\n    def instmid1(self, c, f=1, **kwargs): pass # f as func\n\n    @delegates(instmid1) # to as func type\n    def instmid2(self, c, g=1, **kwargs): pass # f as func \n\nf = Foo1()\ntest_sig(f.instmid1, '(c, f=1, *, e=1, d=1, b=1)')\ntest_sig(f.instmid2, '(c, g=1, *, f=1, e=1, d=1, b=1)')\n\n\nclass Foo():\n    @classmethod\n    def f(cls, a=1, c=2): pass\n\n@delegates(Foo.f) # `to` is a classmethod\ndef low(a, b=1, **kwargs): pass # `f` is a function\ntest_sig(low, '(a, b=1, *, c=2)')\n\n\nclass Foo():\n    def __init__(a, b=1, **kwargs): pass\n\n@delegates(Foo) # `to` is a class\ndef low(c, d=1, **kwargs): pass # `f` as function\n\ntest_sig(low, '(c, d=1, *, b=1)')\n\n\nclass Base(): \n    def __init__(self, a, b=1): pass \nclass Other():\n    def __init__(self, e=1): pass\n\n@delegates(Other)\nclass Foo():    \n    def __new__(self, g, f=1, **kwargs): pass # f as a class is ok with either __new__ or __init__\ntest_sig(Foo, '(g, f=1, *, e=1)')\n\n\n@delegates()\nclass Subcls(Base): # to as a superclass (Base),  to must have __init__, and __new__ won't do. \n    ### why?\n    # As source code required to use Base.__init__, if it doesn't have it, it will use a wrap-slot __init__, which has no __annotations__, and will\n    # cause error when __annotations__ is called later.\n    def __init__(self, c, d=1, **kwargs): pass # f as class, should have __init__\ntest_sig(Subcls, '(c, d=1, *, b=1)')\n\n\n@delegates(Other) # as a normal class, it must have __init__, and __new__ won't do\nclass Foo():    \n    def __init__(self, c, d=1, **kwargs): pass\ntest_sig(Foo, '(c, d=1, *, e=1)')\n\n\ntry: \n    @delegates(Other)\n    class Foo(): pass # f as a class at least needs to have a signature with **kwargs inside\n    ### why? because we expect f to have **kwargs in the source.\nexcept: \n    pprint(inspect.signature(Foo))\n\n<Signature (c, d=1, *, e=1)>\n\n\n\n\ndebugging the error to understand the source"
  },
  {
    "objectID": "fastcore/meta/00_delegates.html#annotation-source",
    "href": "fastcore/meta/00_delegates.html#annotation-source",
    "title": "fastcore.meta.delegates",
    "section": "Annotation Source",
    "text": "Annotation Source\n\ndelegates??\n\n\nSignature: delegates(to: function = None, keep=False, but: list = None)\nSource:   \ndef delegates(to:FunctionType=None, # Delegatee\n              keep=False, # Keep `kwargs` in decorated function?\n              but:list=None): # Exclude these parameters from signature\n    \"Decorator: replace `**kwargs` in signature with params from `to`\"\n    if but is None: but = []\n    def _f(f):\n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n        from_f = getattr(from_f,'__func__',from_f)\n        to_f = getattr(to_f,'__func__',to_f)\n        if hasattr(from_f,'__delwrap__'): return f\n        sig = inspect.signature(from_f)\n        sigd = dict(sig.parameters)\n        k = sigd.pop('kwargs')\n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()\n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}\n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}\n        sigd.update(s2)\n        if keep: sigd['kwargs'] = k\n        else: from_f.__delwrap__ = to_f\n        from_f.__signature__ = sig.replace(parameters=sigd.values())\n        if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)\n        return f\n    return _f\nFile:      ~/mambaforge/lib/python3.9/site-packages/fastcore/meta.py\nType:      function\n\n\n\n\n\ndef delegatesdb(to:FunctionType=None, # Delegatee\n              keep=False, # Keep `kwargs` in decorated function?\n              but:list=None): # Exclude these parameters from signature\n              # verbose=True): # Include `to` in docments?\n    \"Decorator: replace `**kwargs` in signature with params from `to`\"\n    \n    \"\\nWhen `f` overwrite `to` (or simply just want to use\\\n    `to`'s kwargs), it's so convenient to keep `to`'s kwargs inside `f`'s signature instead of just `**kwargs`.\"\n    \n    if but is None: but = []\n    def _f(f):\n        \n        block1 = \"\"\"\nif to is None: to_f,from_f = f.__base__.__init__,f.__init__\nelse:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n        \"\"\"\n        dbprint(block1, \"if to is None: when both to and f are classes\\nif isinstance(to, type): when to is a class\", block1, \"to_f\", \"from_f\", \\\n                \"\\nif to is None:\\n    to_f,from_f = f.__base__.__init__,f.__init__\\n    print(f'f.__base__.__init__: {f.__base__.__init__}, f.__init__: {f.__init__}')\\n    print(f'to_f: {to_f}, from_f: {from_f}')\\nelse:\\n    print(f'to is None : {to is None}')\", \\\n                \"\\nif isinstance(to,type):\\n    to_f,from_f = to.__init__,f\\n    print(f'to_f: {to_f}, from_f: {from_f}')\\nelse:\\n    print(f'isinstance(to,type) : {isinstance(to,type)}')\",\\\n                \"to_f,from_f = to,f\", f=f, to=to)\n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n\n        dbprint(\"from_f = getattr(from_f,'__func__',from_f)\", \"This line is for classmethod, as it is not callable, so inspect.signature(...) won't work, but it has __func__ to save\",\\\n                \"f\", \"from_f\", \"type(from_f)\",\\\n                \"try:\\n    inspect.signature(from_f)\\nexcept:\\n    print('error occurs')\\n    print(f'is from_f callable: {callable(from_f)}')\\nelse:\\n    print(inspect.signature(from_f))\", \\\n                \"hasattr(from_f, '__func__')\", \"from_f = getattr(from_f,'__func__',from_f)\", \"from_f\", from_f=from_f, inspect=inspect)\n        from_f = getattr(from_f,'__func__',from_f)\n        \n        dbprint(\"to_f = getattr(to_f,'__func__',to_f)\", \"This line is for classmethod, as it is not callable, so inspect.signature(...) won't work, but it has __func__ to save\", \\\n                \"to\", \"to_f\", \"type(to_f)\",\\\n                \"try:\\n    inspect.signature(to_f)\\nexcept:\\n    print('error occurs')\\n    print(f'is to_f callable: {callable(to_f)}')\\nelse:\\n    print(inspect.signature(to_f))\", \\\n                \"hasattr(to_f, '__func__')\", \"to_f = getattr(to_f,'__func__',to_f)\", \"to_f\", to_f=to_f)\n        to_f = getattr(to_f,'__func__',to_f)\n        \n        dbprint(\"if hasattr(from_f,'__delwrap__'): return f\", \"If f or from_f has __delwrap__, it means it's happy with all params and give up on **kwargs. So no more params needed from other `to`s\",\\\n                \"from_f\", \"f\", \"hasattr(from_f, '__delwrap__')\", \"if hasattr(from_f,'__delwrap__'): return f\",  from_f=from_f, to_f=to_f)\n        # dbprint(\"if hasattr(from_f,'__delwrap__'): return f\", \"If f or from_f has __delwrap__, it means it's happy with all params and give up on **kwargs. So no more params needed from other `to`s\",\\\n        #         \"from_f\", \"f\", \"hasattr(from_f, '__delwrap__')\",  from_f=from_f, to_f=to_f)\n        if hasattr(from_f,'__delwrap__'): return f\n\n        dbprint(\"sig = inspect.signature(from_f)\", \"\", \"sig = inspect.signature(from_f)\", \"inspect.signature(from_f)\", inspect=inspect)\n        sig = inspect.signature(from_f)\n        \n        dbprint(\"sigd = dict(sig.parameters)\", \"\", \"sigd = dict(sig.parameters)\", \"sig.parameters\", \"dict(sig.parameters)\", sig=sig)\n        sigd = dict(sig.parameters)\n        \n        # remove the item {'kwargs': <Parameter \"**kwargs\">} out of sigd\n        dbprint(\"k = sigd.pop('kwargs')\", \"\", \"sigd\", \"k = sigd.pop('kwargs')\", \"sigd\", \"sigd['kwargs'] = k\", sigd=sigd)\n        k = sigd.pop('kwargs')\n              \n        # build a dict and pick the right keyword args with values into it\n        \n        block2 = \"\"\"s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()                                         \n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}\"\"\"\n        dbprint(block2, \"\", block2, \"s2\", \"for k,v in inspect.signature(to_f).parameters.items():\", \"sigd\", \"but\", \\\n                \"for k,v in inspect.signature(to_f).parameters.items():\\n    print(f'v.default: {v.default}')\\n    print(f'v.default != inspect.Parameter.empty: {v.default != inspect.Parameter.empty}')\\n    print(f'k not in sigd: {k not in sigd}')\\n    print(f'k not in but: {k not in but}')\", \\\n                to_f=to_f, but=but)\n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()\n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}\n        \n        dbprint(\"anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}\", \"\", \\\n                \"anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}\", \"anno\",\\\n                \"for k,v in to_f.__annotations__.items():\", \"sigd\", \"but\")\n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}     \n        \n        dbprint(\"sigd.update(s2)\", \"\", \"s2\", \"sigd\", \"sigd.update(s2)\", \"sigd\", s2=s2)\n        sigd.update(s2)                                                   \n        \n        block3 = \"\"\"\nif keep: sigd['kwargs'] = k\nelse: from_f.__delwrap__ = to_f\n        \"\"\"\n        dbprint(block3, \"\", \"k\", \"keep\", \"sigd\", \"to_f\", \"getattr(from_f, '__delwrap__', None)\", \\\n                \"if keep:\\n    sigd['kwargs'] = k\\nelse:\\n    from_f.__delwrap__ = to_f\", \"sigd\", \"from_f.__delwrap__\", k=k, keep=keep)\n        if keep: sigd['kwargs'] = k\n        else: from_f.__delwrap__ = to_f\n        \n        dbprint(\"from_f.__signature__ = sig.replace(parameters=sigd.values())\", \"\", \"getattr(from_f, '__signature__', None)\", \"sig\", \"sigd.values()\", \\\n               \"inspect.getdoc(sig.replace)\", \"from_f.__signature__ = sig.replace(parameters=sigd.values())\", \\\n                \"getattr(from_f, '__signature__', None)\", sigd=sigd)\n        from_f.__signature__ = sig.replace(parameters=sigd.values())\n        \n        dbprint(\"if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)\", \"\", \"anno\", \"getattr(from_f, '__annotations__', None)\", \\\n                \"if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)\", \"getattr(from_f, '__annotations__', None)\", from_f=from_f, anno=anno)\n        if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)                                                                           \n        return f                                                                                                                                             \n    return _f"
  },
  {
    "objectID": "fastcore/meta/00_delegates.html#add-srcline-and-dbprints",
    "href": "fastcore/meta/00_delegates.html#add-srcline-and-dbprints",
    "title": "fastcore.meta.delegates",
    "section": "Add srcline and dbprints",
    "text": "Add srcline and dbprints\n\nwith open(\"db/delegates\", \"rb\") as fp:   # Unpickling\n  defaults.src2dbp.delegates = pickle.load(fp)\n\n\n# srcdbps = defaults.src2dbp.delegates # user input\nsrcdbps = []\n\n\ndbsrclines(srcname) # check which srclines are debuggable\n# pprint(defaults.src2dbp.delegatesdb.split(\"\\n\"), width=157) # to show which lines have dbcodes already\n\ndef delegates(to:FunctionType=None, # Delegatee                                                                                                              \n              keep=False, # Keep `kwargs` in decorated function?                                                                                             \n              but:list=None): # Exclude these parameters from signature                                                                                      \n    \"Decorator: replace `**kwargs` in signature with params from `to`\"                                                                                       \n    if but is None: but = []                                                                                                                                 \n    def _f(f):                                                                                                                                               \n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__==========================================================================================\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f============================================================================\n        from_f = getattr(from_f,'__func__',from_f)===========================================================================================================\n        to_f = getattr(to_f,'__func__',to_f)=================================================================================================================\n        if hasattr(from_f,'__delwrap__'): return f===========================================================================================================\n        sig = inspect.signature(from_f)                                                                                                                      \n        sigd = dict(sig.parameters)                                                                                                                          \n        k = sigd.pop('kwargs')                                                                                                                               \n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()                                         \n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}                                                                    \n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}===============================================================\n        sigd.update(s2)                                                                                                                                      \n        if keep: sigd['kwargs'] = k                                                                                                                          \n        else: from_f.__delwrap__ = to_f                                                                                                                      \n        from_f.__signature__ = sig.replace(parameters=sigd.values())                                                                                         \n        if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)                                                                           \n        return f                                                                                                                                             \n    return _f                                                                                                                                                \n=============================================================================================================================================================\n\n\n\n\n# srcline = \"\"\n# dbcode = \"\"\"\n# \"\"\"\n\n\n# srcdbps.append([(srcline, dbcode)])\n\n\nsrcline = \"        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}\"\ndbcode = \"\"\"\n        dbprint(\"        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}\", \\\n\"what it does: check to_f's annotations (dict), and only select params with their annotations wanted by f or from_f.\\\\n\\\nwhat is __annotations__: a:int, b:int=1 are annotations\\\\n\\\nfor k,v in to_f.__annotations__.items(): print(f'k:v => {k}:{v}')\\\\n\\\n    if the iterator above is empty, then print won't get executed.\\\\n\\\n    run this:\\\\n\\\n    for k, v in {}.items(): print(f'k:v => {k}:{v}') \", \\\n\"hasattr(to_f, '__annotations__')\", \\\n\"if hasattr(to_f, '__annotations__'):\\\\n\\\n    if bool(to_f.__annotations__.items()) == False:\\\\n\\\n        print(f'to_f.__annotations__.items(): {to_f.__annotations__.items()}')\\\\n\\\n    else:\\\\n\\\n        for k, v in to_f.__annotations__.items():\\\\n\\\n            print(f'k:v => {k}:{v}')\\\\n\\\nelse:\\\\n\\\n    print(f'We should expect error from the code of try-except.')\\\\n\\\n    try:\\\\n\\\n        to_f.__annotations__\\\\n\\\n    except AttributeError as e:\\\\n\\\n        print(e)\", \\\nbut=but, k=k, sigd=sigd, to_f=to_f)\n\"\"\"\n\n\nsrcdbps.append([(srcline, dbcode)])\n\n\nsrcline = \"\"\"\n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n\"\"\"\n\n# watch out: to convert srcline into actual strings for the first arg in dbprint, use '\\\\n\\' instead of just '\\n'\ndbcode = \"\"\"\n\\n        dbprint(\"        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\\\\n\\        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\",\\\n\"UseCase1: when to is superclass to f\\\\nUseCase2: when to is a class but not superclass to f. UseCase3: other combinations\",\\\n\"if to is None:\\\\n\\\n    to_f,from_f = f.__base__.__init__,f.__init__\\\\n\\\nelse:\\\\n\\\n    to_f,from_f = to.__init__ if isinstance(to,type) else to,f\",\\\n\"to_f\", \"from_f\", \"hasattr(to_f, '__annotations__')\", \"hasattr(from_f, '__annotations__')\", \\\nf=f, to=to)\n\"\"\"\n\n\nsrcdbps.append([(srcline, dbcode)])\n\n\nsrcline = \"        if hasattr(from_f,\\'__delwrap__\\'): return f\"\ndbcode = \"\"\"\n        dbprint(\"if hasattr(from_f,'__delwrap__'): return f\", \\\n\"If f or from_f has __delwrap__, it means it's happy with all params and give up on **kwargs. So no more params needed from other `to`s\", \\\n\"from_f\", \"f\", \"hasattr(from_f, '__delwrap__')\", \"if hasattr(from_f,'__delwrap__'): return f\", from_f=from_f, f=f)\n\"\"\"\n\n\nsrcdbps.append([(srcline, dbcode)])\n\n\n# Watch out: using \\\\n instead of \\n inside a block\nsrcline = \"\"\"\n        from_f = getattr(from_f,'__func__',from_f)\n        to_f = getattr(to_f,'__func__',to_f)\n\"\"\"\ndbcode = \"\"\"\n\\n        dbprint(\"        from_f = getattr(from_f,'__func__',from_f)\\\\n\\        to_f = getattr(to_f,'__func__',to_f)\",\\\n\"This line is for classmethod, as it is not callable, so inspect.signature(...) won't work, but it has __func__ to save\",\\\n\"f\", \"from_f\", \"type(from_f)\",\\\n\"try:\\\\n\\\n    inspect.signature(from_f)\\\\n\\\nexcept:\\\\n\\\n    print('error occurs')\\\\n\\\n    print(f'is from_f callable: {callable(from_f)}')\\\\n\\\nelse:\\\\n\\\n    print(inspect.signature(from_f))\", \\\n\"hasattr(from_f, '__func__')\", \"from_f = getattr(from_f,'__func__',from_f)\", \"from_f\",\\\n\"to\", \"to_f\", \"type(to_f)\",\\\n\"try:\\\\n\\\n    inspect.signature(to_f)\\\\n\\\nexcept:\\\\n\\\n    print('error occurs')\\\\n\\\n    print(f'is to_f callable: {callable(to_f)}')\\\\n\\\nelse:\\\\n\\\n    print(inspect.signature(to_f))\", \\\n\"hasattr(to_f, '__func__')\", \"to_f = getattr(to_f,'__func__',to_f)\", \"to_f\",\\\nfrom_f=from_f, to_f=to_f, f=f, to=to, srcline=srcline)\n\"\"\"\n# Importance: must include all necessary env into the dbprint function above. Note, we don't need inspect=inspect because utils has exported `import inspect`\n\n\nsrcdbps.append([(srcline, dbcode)])\n\n\nMatch scrdbps with right order\n\nfor s in srcdbps:\n    print(s[0][0])\n\n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}\n\n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n\n        if hasattr(from_f,'__delwrap__'): return f\n\n        from_f = getattr(from_f,'__func__',from_f)\n        to_f = getattr(to_f,'__func__',to_f)\n\n\n\n\nfor l in defaults.src.split(\"\\n\"):\n    print(l)\n\ndef delegates(to:FunctionType=None, # Delegatee\n              keep=False, # Keep `kwargs` in decorated function?\n              but:list=None): # Exclude these parameters from signature\n    \"Decorator: replace `**kwargs` in signature with params from `to`\"\n    if but is None: but = []\n    def _f(f):\n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n        from_f = getattr(from_f,'__func__',from_f)\n        to_f = getattr(to_f,'__func__',to_f)\n        if hasattr(from_f,'__delwrap__'): return f\n        sig = inspect.signature(from_f)\n        sigd = dict(sig.parameters)\n        k = sigd.pop('kwargs')\n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()\n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}\n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}\n        sigd.update(s2)\n        if keep: sigd['kwargs'] = k\n        else: from_f.__delwrap__ = to_f\n        from_f.__signature__ = sig.replace(parameters=sigd.values())\n        if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)\n        return f\n    return _f\n\n\n\n\nsrcdbps = matchsrcorder(srcdbps)\n\n\nfor s in srcdbps:\n    print(s[0][0])\n\n\n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n\n\n        from_f = getattr(from_f,'__func__',from_f)\n        to_f = getattr(to_f,'__func__',to_f)\n\n        if hasattr(from_f,'__delwrap__'): return f\n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}"
  },
  {
    "objectID": "fastcore/meta/00_delegates.html#save-the-debuggable-source-code",
    "href": "fastcore/meta/00_delegates.html#save-the-debuggable-source-code",
    "title": "fastcore.meta.delegates",
    "section": "Save the debuggable source code",
    "text": "Save the debuggable source code\n\n# save all the srclines with their dbcodes into defaults.\ndefaults.src2dbp.delegates = srcdbps\n\n\n# save the latest debuggable source code into defaults.src2dbp.delegatesdb\ndbsrclines(srcname, dbsrc=True)\n\n\nwith open(\"db/delegates\", \"wb\") as fp:   \n  pickle.dump(defaults.src2dbp.delegates, fp)\n\nwith open(\"db/delegatesdb\", \"wb\") as fp:   \n  pickle.dump(defaults.src2dbp.delegatesdb, fp)"
  },
  {
    "objectID": "fastcore/meta/00_delegates.html#debugging-one-or-more-srclines",
    "href": "fastcore/meta/00_delegates.html#debugging-one-or-more-srclines",
    "title": "fastcore.meta.delegates",
    "section": "Debugging one or more srclines",
    "text": "Debugging one or more srclines\n\ndbsrclines(srcname) # check which srclines are debuggable\n\ndef delegates(to:FunctionType=None, # Delegatee                                                                                                              \n              keep=False, # Keep `kwargs` in decorated function?                                                                                             \n              but:list=None): # Exclude these parameters from signature                                                                                      \n    \"Decorator: replace `**kwargs` in signature with params from `to`\"                                                                                       \n    if but is None: but = []                                                                                                                                 \n    def _f(f):                                                                                                                                               \n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__==========================================================================================\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f============================================================================\n        from_f = getattr(from_f,'__func__',from_f)===========================================================================================================\n        to_f = getattr(to_f,'__func__',to_f)=================================================================================================================\n        if hasattr(from_f,'__delwrap__'): return f===========================================================================================================\n        sig = inspect.signature(from_f)                                                                                                                      \n        sigd = dict(sig.parameters)                                                                                                                          \n        k = sigd.pop('kwargs')                                                                                                                               \n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()                                         \n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}                                                                    \n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}===============================================================\n        sigd.update(s2)                                                                                                                                      \n        if keep: sigd['kwargs'] = k                                                                                                                          \n        else: from_f.__delwrap__ = to_f                                                                                                                      \n        from_f.__signature__ = sig.replace(parameters=sigd.values())                                                                                         \n        if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)                                                                           \n        return f                                                                                                                                             \n    return _f                                                                                                                                                \n=============================================================================================================================================================\n\n\n\n\ndelegates = dbsrclines(srcname, [0,3], retn=True) # print out the debuggable source code under investgation\n\n('def delegates(to:FunctionType=None, # Delegatee\\n'\n '              keep=False, # Keep `kwargs` in decorated function?\\n'\n '              but:list=None): # Exclude these parameters from signature\\n'\n '    \"Decorator: replace `**kwargs` in signature with params from `to`\"\\n'\n '    if but is None: but = []\\n'\n '    def _f(f):\\n'\n '\\n'\n '        dbprint(\"        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\\\\n\\\\        else:          to_f,from_f = to.__init__ if '\n 'isinstance(to,type) else to,f\",\"UseCase1: when to is superclass to f\\\\nUseCase2: when to is a class but not superclass to f. UseCase3: other '\n 'combinations\",\"if to is None:\\\\n    to_f,from_f = f.__base__.__init__,f.__init__\\\\nelse:\\\\n    to_f,from_f = to.__init__ if isinstance(to,type) else '\n 'to,f\",\"to_f\", \"from_f\", \"hasattr(to_f, \\'__annotations__\\')\", \"hasattr(from_f, \\'__annotations__\\')\", f=f, to=to)\\n'\n '\\n'\n '        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\\n'\n '        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\\n'\n \"        from_f = getattr(from_f,'__func__',from_f)\\n\"\n \"        to_f = getattr(to_f,'__func__',to_f)\\n\"\n \"        if hasattr(from_f,'__delwrap__'): return f\\n\"\n '        sig = inspect.signature(from_f)\\n'\n '        sigd = dict(sig.parameters)\\n'\n \"        k = sigd.pop('kwargs')\\n\"\n '        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()\\n'\n '              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}\\n'\n '\\n'\n '        dbprint(\"        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}\", \"what it does: check to_f\\'s '\n 'annotations (dict), and only select params with their annotations wanted by f or from_f.\\\\nwhat is __annotations__: a:int, b:int=1 are annotations\\\\nfor '\n \"k,v in to_f.__annotations__.items(): print(f'k:v => {k}:{v}')\\\\n    if the iterator above is empty, then print won't get executed.\\\\n    run this:\\\\n    \"\n 'for k, v in {}.items(): print(f\\'k:v => {k}:{v}\\') \", \"hasattr(to_f, \\'__annotations__\\')\", \"if hasattr(to_f, \\'__annotations__\\'):\\\\n    if '\n \"bool(to_f.__annotations__.items()) == False:\\\\n        print(f'to_f.__annotations__.items(): {to_f.__annotations__.items()}')\\\\n    else:\\\\n        for \"\n \"k, v in to_f.__annotations__.items():\\\\n            print(f'k:v => {k}:{v}')\\\\nelse:\\\\n    print(f'We should expect error from the code of \"\n 'try-except.\\')\\\\n    try:\\\\n        to_f.__annotations__\\\\n    except AttributeError as e:\\\\n        print(e)\", but=but, k=k, sigd=sigd, to_f=to_f)\\n'\n '\\n'\n '        return None\\n'\n '        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}\\n'\n '        sigd.update(s2)\\n'\n \"        if keep: sigd['kwargs'] = k\\n\"\n '        else: from_f.__delwrap__ = to_f\\n'\n '        from_f.__signature__ = sig.replace(parameters=sigd.values())\\n'\n \"        if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)\\n\"\n '        return f\\n'\n '    return _f\\n')\n\n\n\ndefaults.eg = \"\"\"\nclass Base(): \n    def __init__(self, a, b=1): pass \nclass Other():\n    def __init__(self, e=1): pass\n\n@delegates()\nclass Subcls(Base): # to as a superclass (Base),  to must have __init__, and __new__ won't do\n    def __init__(self, c, d=1, **kwargs): pass # f as class, should have __init__\ntest_sig(Subcls, '(c, d=1, *, b=1)')\n\"\"\"\n\nclass Base(): \n    def __init__(self, a, b=1): pass \nclass Other():\n    def __init__(self, e=1): pass\n\n@delegates()\nclass Subcls(Base): # to as a superclass (Base),  to must have __init__, and __new__ won't do\n    def __init__(self, c, d=1, **kwargs): pass # f as class, should have __init__\n# test_sig(Subcls, '(c, d=1, *, b=1)')\n\n\n\n######################################################## source code with lines under investigation #########################################################\n\n\ndef delegates(to:FunctionType=None, # Delegatee                                                                                                              \n              keep=False, # Keep `kwargs` in decorated function?                                                                                             \n              but:list=None): # Exclude these parameters from signature                                                                                      \n    \"Decorator: replace `**kwargs` in signature with params from `to`\"                                                                                       \n    if but is None: but = []                                                                                                                                 \n    def _f(f):                                                                                                                                               \n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__==========================================================================================\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f============================================================================\n                                                                           UseCase1: when to is superclass to f\n                                                                           UseCase2: when to is a class but not superclass to f. UseCase3: other combinations\n        from_f = getattr(from_f,'__func__',from_f)                                                                                                           \n        to_f = getattr(to_f,'__func__',to_f)                                                                                                                 \n        if hasattr(from_f,'__delwrap__'): return f                                                                                                           \n        sig = inspect.signature(from_f)                                                                                                                      \n        sigd = dict(sig.parameters)                                                                                                                          \n        k = sigd.pop('kwargs')                                                                                                                               \n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()                                         \n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}                                                                    \n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}                                                               \n        sigd.update(s2)                                                                                                                                      \n        if keep: sigd['kwargs'] = k                                                                                                                          \n        else: from_f.__delwrap__ = to_f                                                                                                                      \n        from_f.__signature__ = sig.replace(parameters=sigd.values())                                                                                         \n        if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)                                                                           \n        return f                                                                                                                                             \n    return _f                                                                                                                                                \n                                                                                                                                                             \n\nclass Base(): \n    def __init__(self, a, b=1): pass \nclass Other():\n    def __init__(self, e=1): pass\n\n@delegates()\nclass Subcls(Base): # to as a superclass (Base),  to must have __init__, and __new__ won't do\n    def __init__(self, c, d=1, **kwargs): pass # f as class, should have __init__\ntest_sig(Subcls, '(c, d=1, *, b=1)')\n\n\n\nif to is None:\n    to_f,from_f = f.__base__.__init__,f.__init__\nelse:\n    to_f,from_f = to.__init__ if isinstance(to,type) else to,f                         \n                                                                                                                                  Running your code block => \nThe code block printout => : \n\n\n                                                                                                       to_f => to_f : <function Base.__init__>\n\n\n                                                                                                 from_f => from_f : <function Subcls.__init__>\n\n\n                                                                                  hasattr(to_f, '__annotations__') => hasattr(to_f, '__annotations__') : True\n\n\n                                                                              hasattr(from_f, '__annotations__') => hasattr(from_f, '__annotations__') : True\n\n\n######################################################## source code with lines under investigation #########################################################\n\n\ndef delegates(to:FunctionType=None, # Delegatee                                                                                                              \n              keep=False, # Keep `kwargs` in decorated function?                                                                                             \n              but:list=None): # Exclude these parameters from signature                                                                                      \n    \"Decorator: replace `**kwargs` in signature with params from `to`\"                                                                                       \n    if but is None: but = []                                                                                                                                 \n    def _f(f):                                                                                                                                               \n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__                                                                                          \n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f                                                                            \n        from_f = getattr(from_f,'__func__',from_f)                                                                                                           \n        to_f = getattr(to_f,'__func__',to_f)                                                                                                                 \n        if hasattr(from_f,'__delwrap__'): return f                                                                                                           \n        sig = inspect.signature(from_f)                                                                                                                      \n        sigd = dict(sig.parameters)                                                                                                                          \n        k = sigd.pop('kwargs')                                                                                                                               \n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()                                         \n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}                                                                    \n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}===============================================================\n                                          what it does: check to_f's annotations (dict), and only select params with their annotations wanted by f or from_f.\n                                          what is __annotations__: a:int, b:int=1 are annotations\n                                          for k,v in to_f.__annotations__.items(): print(f'k:v => {k}:{v}')\n                                              if the iterator above is empty, then print won't get executed.\n                                              run this:\n                                              for k, v in {}.items(): print(f'k:v => {k}:{v}') \n        sigd.update(s2)                                                                                                                                      \n        if keep: sigd['kwargs'] = k                                                                                                                          \n        else: from_f.__delwrap__ = to_f                                                                                                                      \n        from_f.__signature__ = sig.replace(parameters=sigd.values())                                                                                         \n        if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)                                                                           \n        return f                                                                                                                                             \n    return _f                                                                                                                                                \n                                                                                                                                                             \n\nclass Base(): \n    def __init__(self, a, b=1): pass \nclass Other():\n    def __init__(self, e=1): pass\n\n@delegates()\nclass Subcls(Base): # to as a superclass (Base),  to must have __init__, and __new__ won't do\n    def __init__(self, c, d=1, **kwargs): pass # f as class, should have __init__\ntest_sig(Subcls, '(c, d=1, *, b=1)')\n\n\n\n                                                                                  hasattr(to_f, '__annotations__') => hasattr(to_f, '__annotations__') : True\n\n\nif hasattr(to_f, '__annotations__'):\n    if bool(to_f.__annotations__.items()) == False:\n        print(f'to_f.__annotations__.items(): {to_f.__annotations__.items()}')\n    else:\n        for k, v in to_f.__annotations__.items():\n            print(f'k:v => {k}:{v}')\nelse:\n    print(f'We should expect error from the code of try-except.')\n    try:\n        to_f.__annotations__\n    except AttributeError as e:\n        print(e)\n                                                                                                                                  Running your code block => \nThe code block printout => : \nto_f.__annotations__.items(): dict_items([])\n\n\n\ndefaults.eg = \"\"\"\nclass Base(): \n    def __init__(self, a, b=1): pass \nclass Other():\n    def __init__(self, e=1): pass\n\n@delegates()\nclass Subcls(Base): # to as a superclass (Base),  to must have __init__, and __new__ won't do\n    def __init__(self, c, d=1, **kwargs): pass # f as class, should have __init__\ntest_sig(Subcls, '(c, d=1, *, b=1)')\n\"\"\"\n\nclass Base(): \n    def __init__(self, a:int, b:int=1): pass \nclass Other():\n    def __init__(self, e=1): pass\n\n@delegates()\nclass Subcls(Base): # to as a superclass (Base),  to must have __init__, and __new__ won't do\n    def __init__(self, c, d=1, **kwargs): pass # f as class, should have __init__\n# test_sig(Subcls, '(c, d=1, *, b=1)')\n\n\n\n######################################################## source code with lines under investigation #########################################################\n\n\ndef delegates(to:FunctionType=None, # Delegatee                                                                                                              \n              keep=False, # Keep `kwargs` in decorated function?                                                                                             \n              but:list=None): # Exclude these parameters from signature                                                                                      \n    \"Decorator: replace `**kwargs` in signature with params from `to`\"                                                                                       \n    if but is None: but = []                                                                                                                                 \n    def _f(f):                                                                                                                                               \n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__==========================================================================================\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f============================================================================\n                                                                           UseCase1: when to is superclass to f\n                                                                           UseCase2: when to is a class but not superclass to f. UseCase3: other combinations\n        from_f = getattr(from_f,'__func__',from_f)                                                                                                           \n        to_f = getattr(to_f,'__func__',to_f)                                                                                                                 \n        if hasattr(from_f,'__delwrap__'): return f                                                                                                           \n        sig = inspect.signature(from_f)                                                                                                                      \n        sigd = dict(sig.parameters)                                                                                                                          \n        k = sigd.pop('kwargs')                                                                                                                               \n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()                                         \n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}                                                                    \n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}                                                               \n        sigd.update(s2)                                                                                                                                      \n        if keep: sigd['kwargs'] = k                                                                                                                          \n        else: from_f.__delwrap__ = to_f                                                                                                                      \n        from_f.__signature__ = sig.replace(parameters=sigd.values())                                                                                         \n        if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)                                                                           \n        return f                                                                                                                                             \n    return _f                                                                                                                                                \n                                                                                                                                                             \n\nclass Base(): \n    def __init__(self, a, b=1): pass \nclass Other():\n    def __init__(self, e=1): pass\n\n@delegates()\nclass Subcls(Base): # to as a superclass (Base),  to must have __init__, and __new__ won't do\n    def __init__(self, c, d=1, **kwargs): pass # f as class, should have __init__\ntest_sig(Subcls, '(c, d=1, *, b=1)')\n\n\n\nif to is None:\n    to_f,from_f = f.__base__.__init__,f.__init__\nelse:\n    to_f,from_f = to.__init__ if isinstance(to,type) else to,f                         \n                                                                                                                                  Running your code block => \nThe code block printout => : \n\n\n                                                                                                       to_f => to_f : <function Base.__init__>\n\n\n                                                                                                 from_f => from_f : <function Subcls.__init__>\n\n\n                                                                                  hasattr(to_f, '__annotations__') => hasattr(to_f, '__annotations__') : True\n\n\n                                                                              hasattr(from_f, '__annotations__') => hasattr(from_f, '__annotations__') : True\n\n\n######################################################## source code with lines under investigation #########################################################\n\n\ndef delegates(to:FunctionType=None, # Delegatee                                                                                                              \n              keep=False, # Keep `kwargs` in decorated function?                                                                                             \n              but:list=None): # Exclude these parameters from signature                                                                                      \n    \"Decorator: replace `**kwargs` in signature with params from `to`\"                                                                                       \n    if but is None: but = []                                                                                                                                 \n    def _f(f):                                                                                                                                               \n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__                                                                                          \n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f                                                                            \n        from_f = getattr(from_f,'__func__',from_f)                                                                                                           \n        to_f = getattr(to_f,'__func__',to_f)                                                                                                                 \n        if hasattr(from_f,'__delwrap__'): return f                                                                                                           \n        sig = inspect.signature(from_f)                                                                                                                      \n        sigd = dict(sig.parameters)                                                                                                                          \n        k = sigd.pop('kwargs')                                                                                                                               \n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()                                         \n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}                                                                    \n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}===============================================================\n                                          what it does: check to_f's annotations (dict), and only select params with their annotations wanted by f or from_f.\n                                          what is __annotations__: a:int, b:int=1 are annotations\n                                          for k,v in to_f.__annotations__.items(): print(f'k:v => {k}:{v}')\n                                              if the iterator above is empty, then print won't get executed.\n                                              run this:\n                                              for k, v in {}.items(): print(f'k:v => {k}:{v}') \n        sigd.update(s2)                                                                                                                                      \n        if keep: sigd['kwargs'] = k                                                                                                                          \n        else: from_f.__delwrap__ = to_f                                                                                                                      \n        from_f.__signature__ = sig.replace(parameters=sigd.values())                                                                                         \n        if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)                                                                           \n        return f                                                                                                                                             \n    return _f                                                                                                                                                \n                                                                                                                                                             \n\nclass Base(): \n    def __init__(self, a, b=1): pass \nclass Other():\n    def __init__(self, e=1): pass\n\n@delegates()\nclass Subcls(Base): # to as a superclass (Base),  to must have __init__, and __new__ won't do\n    def __init__(self, c, d=1, **kwargs): pass # f as class, should have __init__\ntest_sig(Subcls, '(c, d=1, *, b=1)')\n\n\n\n                                                                                  hasattr(to_f, '__annotations__') => hasattr(to_f, '__annotations__') : True\n\n\nif hasattr(to_f, '__annotations__'):\n    if bool(to_f.__annotations__.items()) == False:\n        print(f'to_f.__annotations__.items(): {to_f.__annotations__.items()}')\n    else:\n        for k, v in to_f.__annotations__.items():\n            print(f'k:v => {k}:{v}')\nelse:\n    print(f'We should expect error from the code of try-except.')\n    try:\n        to_f.__annotations__\n    except AttributeError as e:\n        print(e)\n                                                                                                                                  Running your code block => \nThe code block printout => : \nk:v => a:<class 'int'>\nk:v => b:<class 'int'>\n\n\n\ndefaults.eg = \"\"\"\nclass Base(): \n    def __new__(self, a, b=1): pass \nclass Other():\n    def __init__(self, e=1): pass\n\n@delegates()\nclass Subcls(Base): # to as a superclass (Base),  to must have __init__, and __new__ won't do\n    def __init__(self, c, d=1, **kwargs): pass # f as class, should have __init__\ntest_sig(Subcls, '(c, d=1, *, b=1)')\n\"\"\"\n\nclass Base(): \n    def __new__(self, a, b=1): pass \nclass Other():\n    def __init__(self, e=1): pass\n\n@delegates()\nclass Subcls(Base): # to as a superclass (Base),  to must have __init__, and __new__ won't do\n    def __init__(self, c, d=1, **kwargs): pass # f as class, should have __init__\n# test_sig(Subcls, '(c, d=1, *, b=1)')\n\n\n\n######################################################## source code with lines under investigation #########################################################\n\n\ndef delegates(to:FunctionType=None, # Delegatee                                                                                                              \n              keep=False, # Keep `kwargs` in decorated function?                                                                                             \n              but:list=None): # Exclude these parameters from signature                                                                                      \n    \"Decorator: replace `**kwargs` in signature with params from `to`\"                                                                                       \n    if but is None: but = []                                                                                                                                 \n    def _f(f):                                                                                                                                               \n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__==========================================================================================\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f============================================================================\n                                                                           UseCase1: when to is superclass to f\n                                                                           UseCase2: when to is a class but not superclass to f. UseCase3: other combinations\n        from_f = getattr(from_f,'__func__',from_f)                                                                                                           \n        to_f = getattr(to_f,'__func__',to_f)                                                                                                                 \n        if hasattr(from_f,'__delwrap__'): return f                                                                                                           \n        sig = inspect.signature(from_f)                                                                                                                      \n        sigd = dict(sig.parameters)                                                                                                                          \n        k = sigd.pop('kwargs')                                                                                                                               \n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()                                         \n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}                                                                    \n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}                                                               \n        sigd.update(s2)                                                                                                                                      \n        if keep: sigd['kwargs'] = k                                                                                                                          \n        else: from_f.__delwrap__ = to_f                                                                                                                      \n        from_f.__signature__ = sig.replace(parameters=sigd.values())                                                                                         \n        if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)                                                                           \n        return f                                                                                                                                             \n    return _f                                                                                                                                                \n                                                                                                                                                             \n\nclass Base(): \n    def __new__(self, a, b=1): pass \nclass Other():\n    def __init__(self, e=1): pass\n\n@delegates()\nclass Subcls(Base): # to as a superclass (Base),  to must have __init__, and __new__ won't do\n    def __init__(self, c, d=1, **kwargs): pass # f as class, should have __init__\ntest_sig(Subcls, '(c, d=1, *, b=1)')\n\n\n\nif to is None:\n    to_f,from_f = f.__base__.__init__,f.__init__\nelse:\n    to_f,from_f = to.__init__ if isinstance(to,type) else to,f                         \n                                                                                                                                  Running your code block => \nThe code block printout => : \n\n\n                                                                                                 to_f => to_f : <slot wrapper '__init__' of 'object' objects>\n\n\n                                                                                                 from_f => from_f : <function Subcls.__init__>\n\n\n                                                                                 hasattr(to_f, '__annotations__') => hasattr(to_f, '__annotations__') : False\n\n\n                                                                              hasattr(from_f, '__annotations__') => hasattr(from_f, '__annotations__') : True\n\n\n######################################################## source code with lines under investigation #########################################################\n\n\ndef delegates(to:FunctionType=None, # Delegatee                                                                                                              \n              keep=False, # Keep `kwargs` in decorated function?                                                                                             \n              but:list=None): # Exclude these parameters from signature                                                                                      \n    \"Decorator: replace `**kwargs` in signature with params from `to`\"                                                                                       \n    if but is None: but = []                                                                                                                                 \n    def _f(f):                                                                                                                                               \n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__                                                                                          \n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f                                                                            \n        from_f = getattr(from_f,'__func__',from_f)                                                                                                           \n        to_f = getattr(to_f,'__func__',to_f)                                                                                                                 \n        if hasattr(from_f,'__delwrap__'): return f                                                                                                           \n        sig = inspect.signature(from_f)                                                                                                                      \n        sigd = dict(sig.parameters)                                                                                                                          \n        k = sigd.pop('kwargs')                                                                                                                               \n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()                                         \n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}                                                                    \n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}===============================================================\n                                          what it does: check to_f's annotations (dict), and only select params with their annotations wanted by f or from_f.\n                                          what is __annotations__: a:int, b:int=1 are annotations\n                                          for k,v in to_f.__annotations__.items(): print(f'k:v => {k}:{v}')\n                                              if the iterator above is empty, then print won't get executed.\n                                              run this:\n                                              for k, v in {}.items(): print(f'k:v => {k}:{v}') \n        sigd.update(s2)                                                                                                                                      \n        if keep: sigd['kwargs'] = k                                                                                                                          \n        else: from_f.__delwrap__ = to_f                                                                                                                      \n        from_f.__signature__ = sig.replace(parameters=sigd.values())                                                                                         \n        if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)                                                                           \n        return f                                                                                                                                             \n    return _f                                                                                                                                                \n                                                                                                                                                             \n\nclass Base(): \n    def __new__(self, a, b=1): pass \nclass Other():\n    def __init__(self, e=1): pass\n\n@delegates()\nclass Subcls(Base): # to as a superclass (Base),  to must have __init__, and __new__ won't do\n    def __init__(self, c, d=1, **kwargs): pass # f as class, should have __init__\ntest_sig(Subcls, '(c, d=1, *, b=1)')\n\n\n\n                                                                                 hasattr(to_f, '__annotations__') => hasattr(to_f, '__annotations__') : False\n\n\nif hasattr(to_f, '__annotations__'):\n    if bool(to_f.__annotations__.items()) == False:\n        print(f'to_f.__annotations__.items(): {to_f.__annotations__.items()}')\n    else:\n        for k, v in to_f.__annotations__.items():\n            print(f'k:v => {k}:{v}')\nelse:\n    print(f'We should expect error from the code of try-except.')\n    try:\n        to_f.__annotations__\n    except AttributeError as e:\n        print(e)\n                                                                                                                                  Running your code block => \nThe code block printout => : \nWe should expect error from the code of try-except.\n'wrapper_descriptor' object has no attribute '__annotations__'"
  },
  {
    "objectID": "fastcore/meta/01_mk_param.html",
    "href": "fastcore/meta/01_mk_param.html",
    "title": "fastcore.meta._mk_param",
    "section": "",
    "text": "from fastcore.imports import *\nfrom fastcore.meta import *\nfrom fastcore.test import *\nimport inspect\nfrom debuggable.utils import dbprint, defaults, whichversion, defaults\nfrom pprint import pprint\nfrom datetime import date\nimport ast"
  },
  {
    "objectID": "fastcore/meta/01_mk_param.html#sources",
    "href": "fastcore/meta/01_mk_param.html#sources",
    "title": "fastcore.meta._mk_param",
    "section": "Sources",
    "text": "Sources\ndef _mk_param(n,d=None): return inspect.Parameter(n, inspect.Parameter.KEYWORD_ONLY, default=d)\n\ninspect.Parameter?\n\n\ndef _mk_param(n,d=None): \n    \"Create a parameter with name and a default value None, the kind is fixed on Keyword_only.\"\n    \n    dbprint(\"inspect.Parameter(n, inspect.Parameter.KEYWORD_ONLY, default=d)\", \"n\", \"d\", \"inspect.Parameter.KEYWORD_ONLY\", \\\n            \"param = inspect.Parameter(n, inspect.Parameter.KEYWORD_ONLY, default=d)\", \"type(param)\", n=n, d=d, inspect=inspect)\n    \n    return inspect.Parameter(n, inspect.Parameter.KEYWORD_ONLY, default=d)\n\n\nfrom fastcore.meta import _mk_param as mp\ndefaults.src = inspect.getsource(mp)\ndefaults.deb = inspect.getsource(_mk_param)\ndefaults.checksource()\n\n\ndefaults.eg=\"\"\"\n_mk_param(\"p\")\n\"\"\"\n\n\n_mk_param(\"p\")"
  },
  {
    "objectID": "fastcore/meta/01_mk_param.html#examples",
    "href": "fastcore/meta/01_mk_param.html#examples",
    "title": "fastcore.meta._mk_param",
    "section": "Examples",
    "text": "Examples\nofficial docs\ns2 = {n:_mk_param(n,d) for n,d in kwargs.items() if n not in sigd}\ns2 = {n:_mk_param(n) for n in names if n not in sigd}"
  },
  {
    "objectID": "fastcore/findings/00F_delegates_keep.html",
    "href": "fastcore/findings/00F_delegates_keep.html",
    "title": "Findings from fastcore.meta.delegates",
    "section": "",
    "text": "from fastcore.imports import *\nfrom fastcore.meta import *\nfrom nbdev.showdoc import *\nfrom fastcore.test import *\nfrom pprint import pprint\nfrom debuggable.utils import *\nimport inspect"
  },
  {
    "objectID": "fastcore/findings/00F_delegates_keep.html#the-undocumented-feature-of-arg-keep-in-function-delegates",
    "href": "fastcore/findings/00F_delegates_keep.html#the-undocumented-feature-of-arg-keep-in-function-delegates",
    "title": "Findings from fastcore.meta.delegates",
    "section": "The undocumented feature of arg keep in function delegates",
    "text": "The undocumented feature of arg keep in function delegates\nThe docs of delegates tells us if keep=False, **kwargs of func mid (example below) will be removed; keep=True will keep **kwargs for mid.\nBut do you know keep=False has an untold feature, which is keep=False will make sure the mid won’t take any more args from other tos. In other words, after delegates(low, keep=False)(mid), delegates(low2)(mid) won’t change the signature of mid. This is a useful feature of keep of delegates but not documented.\nIn the example below, you can’t delegates args of low2 to mid after receiving args from low.\n\ndef low(a, b=1): pass\n@delegates(low)\ndef mid(c, d:int=1, **kwargs): pass\nmid\n\n<function __main__.mid(c, d: int = 1, *, b=1)>\n\n\n\ndef low2(e, f=1, **kwargs): pass\ndelegates(low2)(mid)\n\n<function __main__.mid(c, d: int = 1, *, b=1)>\n\n\nHowever, when you set keep=True, **kwargs stays with mid signature, and mid can receive arg g from low2 by using delegates again.\n\ndef low(a, b=1): pass\n@delegates(low, keep=True)\ndef mid(c, d:int=1, **kwargs): pass\ndef low2(e, g=1): pass\ndelegates(low2)(mid)\n\n<function __main__.mid(c, d: int = 1, *, b=1, g=1)>"
  },
  {
    "objectID": "fastcore/findings/00F_delegates_keep.html#the-hidden-or-unexpected-feature-of-keep-of-delegates",
    "href": "fastcore/findings/00F_delegates_keep.html#the-hidden-or-unexpected-feature-of-keep-of-delegates",
    "title": "Findings from fastcore.meta.delegates",
    "section": "The hidden or unexpected feature of keep of delegates",
    "text": "The hidden or unexpected feature of keep of delegates\nWhen keep=False, show_doc can tell you where b come from in the example below.\nWhen keep=True, show_doc can’t show the address info of b.\nSo, you are out of luck, if you want to keep both **kwargs and display the address info of b at the same time.\nNote: see how f.__delwrap__ help showdoc to generate the address info of b from here.\n\n\nmid\n\n mid (c, d=1, b=1)\n\n\n\n\nhigh\n\n high (e, f=1, d=1, b=1)\n\nYou can keep **kwargs, but you can’t have the address info of b for mid, and d and b for high.\n\n\n\nmid\n\n mid (c, d=1, b=1, **kwargs)\n\n\n\n\nhigh\n\n high (e, f=1, d=1, b=1, **kwargs)"
  },
  {
    "objectID": "fastcore/findings/00F_delegates_keep.html#is-there-a-legitimate-use-case-for-keeping-both-kwargs-and-the-address-info-of-b",
    "href": "fastcore/findings/00F_delegates_keep.html#is-there-a-legitimate-use-case-for-keeping-both-kwargs-and-the-address-info-of-b",
    "title": "Findings from fastcore.meta.delegates",
    "section": "Is there a legitimate use case for keeping both **kwargs and the address info of b?",
    "text": "Is there a legitimate use case for keeping both **kwargs and the address info of b?\nI think so, and here is a case example below.\nThe function low need **kwargs to override y from lower and mid needs **kwargs to override b from low. Therefore, **kwargs should be kept using keep=True.\nThe signature of mid does not tell us where b is from, it would be useful to show us the address info of b. But the current official delegates doesn’t allow you to have both.\nIf you agree this use case is legitimate, then the unexpected feature here is an issue need to be resolved.\n\ndef lower(x, y=1): return x + y\ndef low(a, b=1, **kwargs): return lower(a, **kwargs) + b\n@delegates(low, keep=True)\ndef mid(c, d=1, **kwargs): return low(c, **kwargs) + d\nmid\n\n<function __main__.mid(c, d=1, *, b=1, **kwargs)>\n\n\n\nmid(1, 1, b=1, y=2)\n\n5\n\n\n\n\nmid\n\n mid (c, d=1, b=1, **kwargs)"
  },
  {
    "objectID": "fastcore/findings/00F_delegates_keep.html#can-we-enable-delegates-to-allow-both-keeping-kwargs-and-display-address-info-of-args-from-to",
    "href": "fastcore/findings/00F_delegates_keep.html#can-we-enable-delegates-to-allow-both-keeping-kwargs-and-display-address-info-of-args-from-to",
    "title": "Findings from fastcore.meta.delegates",
    "section": "Can we enable delegates to allow both keeping **kwargs and display address info of args from to?",
    "text": "Can we enable delegates to allow both keeping **kwargs and display address info of args from to?\nThe cause for disallowing the use case above is keep=True and from_f.__delwrap__ are tied together. The problem can be solved if we untie them, and keep from_f.__delwrap__ always available to from_f.\n\ndelegates??\n\n\nSignature: delegates(to: function = None, keep=False, but: list = None)\nSource:   \ndef delegates(to:FunctionType=None, # Delegatee\n              keep=False, # Keep `kwargs` in decorated function?\n              but:list=None): # Exclude these parameters from signature\n    \"Decorator: replace `**kwargs` in signature with params from `to`\"\n    if but is None: but = []\n    def _f(f):\n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n        from_f = getattr(from_f,'__func__',from_f)\n        to_f = getattr(to_f,'__func__',to_f)\n        if hasattr(from_f,'__delwrap__'): return f\n        sig = inspect.signature(from_f)\n        sigd = dict(sig.parameters)\n        k = sigd.pop('kwargs')\n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()\n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}\n        anno = {k:v for k,v in to_f.__annotations__.items() if k not in sigd and k not in but}\n        sigd.update(s2)\n        if keep: sigd['kwargs'] = k\n        else: from_f.__delwrap__ = to_f\n        from_f.__signature__ = sig.replace(parameters=sigd.values())\n        if hasattr(from_f, '__annotations__'): from_f.__annotations__.update(anno)\n        return f\n    return _f\nFile:      ~/mambaforge/lib/python3.9/site-packages/fastcore/meta.py\nType:      function\n\n\n\n\nThe two lines of code need alteration which are marked with ‘###’ below.\n\ndef delegates(to=None, # Delegatee\n              keep=False, # Keep `kwargs` in decorated function?\n              but:list=None, # Exclude these parameters from signature\n              verbose=True): # Include `to` in docments?\n    \"Decorator: replace `**kwargs` in signature with params from `to`\"\n    if but is None: but = []\n    def _f(f):\n        if to is None: to_f,from_f = f.__base__.__init__,f.__init__\n        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f\n        from_f = getattr(from_f,'__func__',from_f)\n        to_f = getattr(to_f,'__func__',to_f)\n        if hasattr(from_f,'__delwrap__') and keep==False: return f ### if you don't want `f` to run delegates again\n        sig = inspect.signature(from_f)\n        sigd = dict(sig.parameters)\n        k = sigd.pop('kwargs')\n        s2 = {k:v.replace(kind=inspect.Parameter.KEYWORD_ONLY) for k,v in inspect.signature(to_f).parameters.items()\n              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}\n        sigd.update(s2)\n        if keep: sigd['kwargs'] = k \n        from_f.__delwrap__ = to_f ### enable show_doc to display the address info for args of `to`\n        \n        from_f.__delopts__ = dict(verbose=verbose)\n        from_f.__signature__ = sig.replace(parameters=sigd.values())\n        return f\n    return _f\n\nNow, you can use keep=True to have both **kwargs and show_doc displaying address info on b\n\ndef lower(x, y=1): return x + y\ndef low(a, b=1, **kwargs): return lower(a, **kwargs) + b\n@delegates(low, keep=True)\ndef mid(c, d=1, **kwargs): return low(c, **kwargs) + d\nmid\n\n<function __main__.mid(c, d=1, *, b=1, **kwargs)>\n\n\n\nmid(1, 1, b=1, y=2)\n\n5\n\n\n\n\nmid\n\n mid (c, d=1, b=1, **kwargs)\n\nNow, you can use keep=False to remove **kwargs but show_doc can still display address info of b.\n\n@delegates(mid, keep=False)\ndef high(e, f=1, **kwargs): pass\nhigh\n\n<function __main__.high(e, f=1, *, d=1, b=1)>\n\n\n\n\n\nhigh\n\n high (e, f=1, d=1, b=1, **kwargs)\n\nNow, you can use keep=False to not only remove **kwargs but also refuse to use delegates again.\n\ndelegates(lower, keep=False)(high)\n\n<function __main__.high(e, f=1, *, d=1, b=1)>"
  },
  {
    "objectID": "fastcore/classes_metaclasses.html",
    "href": "fastcore/classes_metaclasses.html",
    "title": "classes and metaclasses",
    "section": "",
    "text": "Tutorials on metaclass - a lengthy and comprehensive one - a shorter and simpler one\nA basic tutorial on static, class, instance, cls and self.\nA tutorial on super"
  },
  {
    "objectID": "fastcore/classes_metaclasses.html#classes",
    "href": "fastcore/classes_metaclasses.html#classes",
    "title": "classes and metaclasses",
    "section": "Classes",
    "text": "Classes\n\nhow-method: static vs class vs instance methods\n\nclass Sample:\n   \n    @staticmethod\n    def method():\n        print('This is a static method')\n \nSample.method()\n\n\nclass Sample:\n    var = \"Class Variable\"\n    \n    @classmethod\n    def method(cls):\n        print(f\"this is {cls.var}\")\n \nSample.method()\n\n\nclass Sample:\n    def __init__(self, a):\n        self.a = a\n \n    def method(self):\n        print(self.a)\n        print(\"I am an instance method, like `__init__`\")\n \nobj = Sample(10)\nobj.method()\n\n\n\nhow-cls and how-self\ncls refers to the class, whereas self refers to the instance. Using the cls keyword, we can only access the members of the class, whereas using the self keyword, we can access both the instance variables and the class attributes\n\nclass Person:\n    about = 'This class stores the name and age for a person' \n    # class variable/property, no need instance to access it\n \n    def __init__(self, name, age): # instance method\n        self.name = name # define and set an instance variable inside self\n        self.age = age\n \n    def details(self): # \n        print(f\"Person's name is {self.name} and age is {self.age}\")\n\n    def instanceinfo(self):\n        print(self.about) # an instance can access class property or variable\n        self.info() # an instance can access class method too\n        \n    @classmethod # class method\n    def info(cls): # class method use cls, no need instance to access it\n        print(cls.about)"
  },
  {
    "objectID": "fastcore/classes_metaclasses.html#type-and-class",
    "href": "fastcore/classes_metaclasses.html#type-and-class",
    "title": "classes and metaclasses",
    "section": "Type and Class",
    "text": "Type and Class\n\nhow-type: type(obj) is equivalent to obj.__class__\n\nclass Foo: pass\n\nfor obj in (1, [2], {\"three\": 3}, (4), Foo):\n    print(type(obj) is obj.__class__)\n\n\n\nhow-type: type are the class (or metaclass) of classes like int, float, etc\n\nfor t in int, float, dict, list, tuple, Foo, Foo(), object:\n...     print(type(t))\n\n\ntype(type)\n\n\nx is an instance of class Foo.\nFoo is an instance of the type metaclass.\ntype is also an instance of the type metaclass, so it is an instance of itself.\n\n\n\n\ntype\n\n\n\n\nhow-type: create class dynamically using type\nYou can also call type() with three arguments—type(<name>, <bases>, <dct>):\n\n<name> specifies the class name. This becomes the name attribute of the class.\n<bases> specifies a tuple of the base classes from which the class inherits. This becomes the bases attribute of the class.\n<dct> specifies a namespace dictionary containing definitions for the class body. This becomes the dict attribute of the class.\n\n\nExample: Create a class without bases and attributes\n\nFoo = type('Foo', (), {})\nclass Foo: pass\n\n\n\nExample: Create a class with bases and attributes\n\nBar = type('Bar', (Foo,), dict(attr=100))\nclass Bar(Foo): attr = 100\n\n\n\nExample: Create a class without base but attributes and methods\n\nFoo = type('Foo', (), {'attr': 100, 'attr_val': lambda x : x.attr})\nclass Foo: \n    attr = 100 \n    def attr_val(self): return self.attr\n\n\ndef f(obj):\n    print('attr =', obj.attr)\nFoo = type('Foo', (), {'attr': 100,'attr_val': f})\n\ndef f(obj):\n    print('attr =', obj.attr)\nclass Foo:\n    attr = 100\n    attr_val = f"
  },
  {
    "objectID": "fastcore/classes_metaclasses.html#metaclass-customize-your-own-type",
    "href": "fastcore/classes_metaclasses.html#metaclass-customize-your-own-type",
    "title": "classes and metaclasses",
    "section": "metaclass: Customize your own type",
    "text": "metaclass: Customize your own type\n\nWhat exactly happening when you call a class?\n\nclass Foo: pass\nf = Foo()\n\n\ntype(Foo) == Foo.__class__ == type # Foo as a class is created by metaclass type\n\n\nFoo.__bases__ # Foo inherits from object, but is created by type\n\nTo creating a class, interpreter will first run type.__call__ which will run obj.__new__ and obj.__init__\n\ndef new(cls):\n    x = object.__new__(cls) # `__new__` is from object, not type\n    x.attr = 100\n    return x\n\nFoo.__new__ = new\n\n\n\nCan we customize type by customizing its __new__\n# Spoiler alert:  This doesn't work!\ndef new(cls):\n    x = type.__new__(cls)\n    x.attr = 100\n    return x\n\ntype.__new__ = new\nTraceback (most recent call last):\n  File \"<pyshell#77>\", line 1, in <module>\n    type.__new__ = new\nTypeError: can't set attributes of built-in/extension type 'type'\n\n\nhow-type: how to create a type or class dynamically\ntype??\nInit signature: type(self, /, *args, **kwargs)\nDocstring:     \ntype(object) -> the object's type\ntype(name, bases, dict, **kwds) -> a new type\nType:           type\nSubclasses:     ABCMeta, EnumMeta, NamedTupleMeta, _TypedDictMeta, _ABC, MetaHasDescriptors, PyCStructType, UnionType, PyCPointerType, PyCArrayType, ...\n\nclass Meta(type):\n    def __new__(cls, name, bases, dct):\n        x = super().__new__(cls, name, bases, dct)\n        x.attr = 100\n        return x\n\n\ntype(Meta) == Meta.__class__ == type == Meta.__bases__[0] \n# Meta is created by type and inherited from type\n\n\nclass Foo(metaclass=Meta):\n    pass\npprint(Foo.attr)\npprint(Foo.__bases__) # Foo is inherited from object\npprint(type(Foo) == Foo.__class__ == Meta) # Foo is created by Meta\n\n\nF = Meta('Foo', (), {'attr': 100})\npprint(F.attr)\npprint(F.__bases__) # F is inherited from object\npprint(type(F) == F.__class__ == Meta) # F is created by Meta\n\n\n\nMetaclass really necessary?\n\nCreate a class with class attr using metaclass\n\nclass Meta(type):\n    def __init__(\n        cls, name, bases, dct\n    ):\n        cls.attr = 100\n\n\nclass X(metaclass=Meta):\n    pass\nX.attr\n\n\nXm = Meta('X', (), {'attr':100})\nXm.attr\n\n\npprint(type(Xm) == Xm.__class__ == Meta)\npprint(Xm.__bases__)\n\n\n\nUsing simple inheritance\n\nclass Base: attr = 100\nclass X(Base): pass\nX.attr\n\n\npprint(type(X) == X.__class__ == type)\npprint(X.__bases__)\n\n\n\nUsing class decorator\n\ndef decorator(cls):\n    class NewClass(cls): attr = 100\n    return NewClass\n\n@decorator\nclass X: pass\n\nX.attr\n\n\npprint(type(X) == X.__class__ == type)\npprint(X.__bases__)"
  },
  {
    "objectID": "fastcore/classes_metaclasses.html#how-to-make-an-object-callable-with-__call__",
    "href": "fastcore/classes_metaclasses.html#how-to-make-an-object-callable-with-__call__",
    "title": "classes and metaclasses",
    "section": "how to make an object callable with __call__",
    "text": "how to make an object callable with __call__\n\nclass Human:\n    def __init__(self, first_name, last_name):\n        print(\"I am inside __init__ method\")\n        self.first_name = first_name\n        self.last_name = last_name\n\n# The following attempts won't work\n\n#     @staticmethod  \n#     def __call__():\n#         print(\"I am inside __call__ method\")\n\n#     @classmethod\n#     def __call__(cls):\n#         print(\"I am inside __call__ method\")\n\n    def __call__(cls):\n        print(\"I am inside __call__ method using cls as args\")\n        \n    def __call__(self):\n        print(\"I am inside __call__ method using self as args\")\n\n\nh = Human(1,2)\nh() # __call__(self) will take priority over __call__(cls), even though both work on its own\ntry:\n    Human()\nexcept TypeError as e: \n    print(e)\n\n\nh.__call__()"
  },
  {
    "objectID": "fastcore/classes_metaclasses.html#all-classes-inherit-from-object",
    "href": "fastcore/classes_metaclasses.html#all-classes-inherit-from-object",
    "title": "classes and metaclasses",
    "section": "all classes inherit from object",
    "text": "all classes inherit from object\nIn Python3, all classes implicitly inherit from the built-in object base class. To specify explicitly object as a base class won’t be confused with metaclass\n\nclass Human(object): pass\npprint(Human.__class__ == type(Human) == type)\npprint(Human.__bases__)\n\n\nclass Human(): pass\npprint(Human.__class__ == type(Human) == type)\npprint(Human.__bases__)"
  },
  {
    "objectID": "fastcore/classes_metaclasses.html#type-as-metaclass",
    "href": "fastcore/classes_metaclasses.html#type-as-metaclass",
    "title": "classes and metaclasses",
    "section": "Type as metaclass",
    "text": "Type as metaclass\n\nclass Human: pass\npprint(type(Human))\npprint(type(type))\n\n\n\n\ntype flow\n\n\n\n\n\nType flow instantiation\n\n\n\nclass Human:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = a\n\nhuman_obj = Human(1, 2)\nassert isinstance(human_obj, Human) \nassert isinstance(human_obj, object)"
  },
  {
    "objectID": "fastcore/classes_metaclasses.html#object.__new__-and-overriding-it-by-subclasses",
    "href": "fastcore/classes_metaclasses.html#object.__new__-and-overriding-it-by-subclasses",
    "title": "classes and metaclasses",
    "section": "object.__new__ and overriding it by subclasses",
    "text": "object.__new__ and overriding it by subclasses\n\nwhat object.__new__ look like\nobject.__new__??\nSignature: object.__new__(*args, **kwargs)\nDocstring: Create and return a new object.  See help(type) for accurate signature.\nType:      builtin_function_or_method\n# cls - is the mandatory argument. Object returned by the __new__ method is of type cls\n@staticmethod\ndef __new__(cls[,...]):\n    pass\n\n\nWhat overriding object.__new__ look like\n\nclass Human:\n    # no @staticmethod is required when overiding the staticmethod __new__ of object\n    def __new__(cls, first_name=None):\n        # cls = Human. cls is the class using which the object will be created.\n        # Created object will be of type cls.\n        # We must call the object class' __new__ to allocate memory\n        obj = super().__new__(cls) # This is equivalent to object.__new__(cls)\n\n        # receive obj from object.__new__ and modify it inside Human.__new__\n        obj.name = first_name if first_name else \"Virat\"\n\n        # check the object's class or type\n        print(type(obj)) # Prints: <__main__.Human object at 0x103665668>\n        # return the object\n        return obj\n\n# Create an object\n# __init__ method of `object` class will be called.\nvirat = Human()\n\nprint(virat.name)  # Output: Virat\n\nsachin = Human(\"Sachin\")\nprint(sachin.name)  # Output: Sachin\n\n\nclass Animal:\n    def __new__(cls):\n        # cls = Animal, but we don't have to use it.\n        # Passing Human class reference instead of Animal class reference\n        obj = super().__new__(Human) # This is equivalent to object.__new__(Human)\n\n        print(f\"Type of obj: {type(obj)}\") # Prints: Type of obj: <class '__main__.Human'>\n\n        # return the object\n        return obj\n\n# Create an object\ncat = Animal()\n# Output:\n# Type of obj: <class '__main__.Human'>\n\ntype(cat)   # Output: <class '__main__.Human'>"
  },
  {
    "objectID": "fastcore/classes_metaclasses.html#object.__init__-and-overriding-it-by-subclasses",
    "href": "fastcore/classes_metaclasses.html#object.__init__-and-overriding-it-by-subclasses",
    "title": "classes and metaclasses",
    "section": "object.__init__ and overriding it by subclasses",
    "text": "object.__init__ and overriding it by subclasses\n\nclass Human:\n    # overriding object.__init__ with Human.__init__ below\n    def __init__(self, first_name):\n        # self = obj. __init__ received obj from Human.__new__ or object.__new__\n        self.first_name = first_name\n        \n        # NEVER return self in __init__\n        return self\n\ntry:\n    human_obj = Human('Virat')\nexcept TypeError as e: \n    print(e)\n\n\nOverriding both __new__ and __init__\nobject.__init__??\nSignature:      object.__init__(self, /, *args, **kwargs)\nCall signature: object.__init__(*args, **kwargs)\nType:           wrapper_descriptor\nString form:    <slot wrapper '__init__' of 'object' objects>\nNamespace:      Python builtin\nDocstring:      Initialize self.  See help(type(self)) for accurate signature.\n\nclass Human:\n    def __new__(cls, *args, **kwargs):\n        # Here, the __new__ method of the object class must be called to create\n        # and allocate the memory to the object\n        print(\"Inside `__new__` method\")\n        print(f\"args arguments {args}\")\n        print(f\"kwargs arguments {kwargs}\")\n\n        # The code below calls the __new__ method of the object's class.\n        # Object class' __new__ method allocates a memory\n        # for the instance and returns that instance\n        human_obj = super(Human, cls).__new__(cls)\n\n        print(f\"human_obj instance - {human_obj}\")\n        return human_obj\n\n    # As we have overridden the __init__ method, \n    # the __init__ method of the object class will Not Be Called\n    def __init__(self, first_name, last_name):\n        print(\"Inside __init__ method\")\n        # self = human_obj returned from the __new__ method\n\n        self.first_name = first_name\n        self.last_name = last_name\n\n        print(f\"human_obj instance inside __init__ {self}: {self.first_name}, {self.last_name}\")\n\nhuman_obj = Human(\"Virat\", \"Kohli\")"
  },
  {
    "objectID": "fastcore/classes_metaclasses.html#type.__call__",
    "href": "fastcore/classes_metaclasses.html#type.__call__",
    "title": "classes and metaclasses",
    "section": "type.__call__",
    "text": "type.__call__\n\nclass type:\n    def __call__():\n        # Called when class is called i.e. Human()\n        print(\"type's call method\")\n\n\nWho calls the new and init method?\nWho passes the self object to the init method?\nAs the init method is called after the new method, and the init method does not return anything, how does calling the class return the object (i.e., how does calling the Human class return the human_obj object)?\n\n\nclass Human:\n    def __init__(self, first_name, last_name):\n        self.first_name = first_name\n        self.last_name = last_name\n\nhuman_obj = Human(\"Virat\", \"Kohli\")\n\nAs we are talking about CPython, the type class’ call method definition is defined in C language. If we convert it into Python and simplify it, it will look somewhat like this:\n\n# type's __call__ method which gets called when Human class is called i.e. Human()\ndef __call__(cls, *args, **kwargs):\n    # cls = Human class\n    # args = [\"Virat\", \"Kohli\"]\n    # Calling __new__ method of the Human class, as __new__ method is not defined\n    # on Human, __new__ method of the object class is called\n    human_obj = cls.__new__(*args, **kwargs)\n\n    # After __new__ method returns the object, __init__ method will only be called if\n    # 1. human_obj is not None\n    # 2. human_obj is an instance of class Human\n    # 3. __init__ method is defined on the Human class\n    if human_obj is not None and isinstance(human_obj, cls) and hasattr(human_obj, '__init__'):\n        # As __init__ is called on human_obj, self will be equal to human_obj in __init__ method\n        human_obj.init(*args, **kwargs)\n\n    return human_obj\n\n\n\n\ncall-new-init\n\n\n\nIf the __new__ method does not return anything, then init will not be called\nIf the __new__ method did not return human_obj but an integer with value 10, which is not of the Human type; hence, the __init__ method will not be called. Also, human_obj will not have the reference for the created object, but it will refer to an integer value of 10."
  },
  {
    "objectID": "fastcore/classes_metaclasses.html#super-and-inheritance",
    "href": "fastcore/classes_metaclasses.html#super-and-inheritance",
    "title": "classes and metaclasses",
    "section": "super and inheritance",
    "text": "super and inheritance\n\nBasic usages of super\n\nclass Rectangle:\n    # call object.__new__ implicitly\n    \n    # overriding object.__init__ with the following\n    def __init__(self, length, width):\n        self.length = length\n        self.width = width\n\n    def area(self):\n        return self.length * self.width\n\n    def perimeter(self):\n        return 2 * self.length + 2 * self.width\n\n# Here we declare that the Square class inherits from the Rectangle class\nclass Square(Rectangle):\n    # call Rectangle.__new__ implicitly\n\n    # Square needs to override Rectangle.__init__ for its uniqueness\n    def __init__(self, length):\n        # but we can still use Rectangle.__init__ here\n        super().__init__(length, length)\n        \n    # Square can inherit all base class methods and attributes\n        \npprint(Square(1).area())\npprint(Square(1).perimeter())\n\n\nclass Square(Rectangle):\n    def __init__(self, length):\n        super().__init__(length, length)\n\nclass Cube(Square):\n    # call implicitly Square.__new__, and Square.__init__\n    # Cube inherit all methods and attributes from Square\n    \n    def surface_area(self):\n        face_area = super().area() # use Square.area to build Cube.surface_area\n        return face_area * 6\n\n    def volume(self):\n        face_area = super().area() # use Square.area to build Cube.surface_area\n        return face_area * self.length\n\n\n\nDeep dive in super\n\nclass Rectangle:\n    def __init__(self, length, width):\n        self.length = length\n        self.width = width\n\n    def area(self):\n        return self.length * self.width\n\n    def perimeter(self):\n        return 2 * self.length + 2 * self.width\n\nclass Square(Rectangle):\n    def __init__(self, length):\n        super(Square, self).__init__(length, length) \n        # equivalent to super().__init__(length, length)\n\n\nclass Cube(Square):\n    def surface_area(self):\n        face_area = super(Square, self).area()\n        return face_area * 6\n\n    def volume(self):\n        # jump in inheritance ladder, to search inside Rectangle class not Square class\n        face_area = super(Square, self).area()\n        return face_area * self.length\n\n\nHow to understand super(Square, self)\nBy including an instantiated object like self above, super() returns a bound method: a method that is bound to the object, which gives the method the object’s context such as any instance attributes.\nIf this parameter is not included, the method returned is just a function, unassociated with an object’s context\n\n\n\nsuper() in Multiple Inheritance\nPython supports multiple inheritance, in which a subclass can inherit from multiple superclasses that don’t necessarily inherit from each other (also known as sibling classes). \n\nclass Triangle:\n    def __init__(self, base, height):\n        self.base = base\n        self.height = height\n\n    def area(self):\n        return 0.5 * self.base * self.height\n\n\nclass RightPyramid(Triangle, Square): # note the order of super classes\n    def __init__(self, base, slant_height):\n        self.base = base\n        self.slant_height = slant_height\n\n    def area(self):\n        base_area = super().area()\n        perimeter = super().perimeter()\n        return 0.5 * perimeter * self.slant_height + base_area\n\n\npyramid = RightPyramid(2, 4)\ntry:\n    pyramid.area()\nexcept AttributeError as e:\n    print(e)\n\nTraceback (most recent call last):\n  File \"shapes.py\", line 63, in <module>\n    print(pyramid.area())\n  File \"shapes.py\", line 47, in area\n    base_area = super().area()\n  File \"shapes.py\", line 38, in area\n    return 0.5 * self.base * self.height\nAttributeError: 'RightPyramid' object has no attribute 'height'\n\n\nMRO: method resolution order\nThe method resolution order (or MRO) tells Python how to search for inherited methods.\n\nRightPyramid.__mro__\n\n\nRightPyramid.__base__\n\nLuckily, you have some control over how the MRO is constructed. Just by changing the signature of the RightPyramid class, you can search in the order you want, and the methods will resolve correctly:\n\nclass Triangle:\n    def __init__(self, base, height):\n        self.base = base\n        self.height = height\n        super().__init__()\n\n    def tri_area(self):\n        return 0.5 * self.base * self.height\n\nclass RightPyramid(Square, Triangle):\n    def __init__(self, base, slant_height):\n        self.base = base\n#         self.height = base # add this line to avoid tri_area missing height value\n        self.slant_height = slant_height\n        super().__init__(self.base)\n\n    def area(self):\n        base_area = super().area()\n        perimeter = super().perimeter()\n        return 0.5 * perimeter * self.slant_height + base_area\n\n    def area_2(self):\n        base_area = super().area()\n        triangle_area = super().tri_area()\n        return triangle_area * 4 + base_area\n\n\npprint(RightPyramid.__base__)\n\npprint(RightPyramid.__mro__)\n\n\npyramid = RightPyramid(base=2, slant_height=4)\npyramid.area()\ntry:\n    pyramid.area_2()\nexcept AttributeError as e:\n    print(e)\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nInput In [284], in <cell line: 3>()\n      1 pyramid = RightPyramid(base=2, slant_height=4)\n      2 pyramid.area()\n----> 3 pyramid.area_2()\n\nInput In [282], in RightPyramid.area_2(self)\n     22 def area_2(self):\n     23     base_area = super().area()\n---> 24     triangle_area = super().tri_area()\n     25     return triangle_area * 4 + base_area\n\nInput In [282], in Triangle.tri_area(self)\n      7 def tri_area(self):\n----> 8     return 0.5 * self.base * self.height\n\nAttributeError: 'RightPyramid' object has no attribute 'height'\n\n\nhow-kwargs: Using **kwargs to pass values to superclasses\n\nclass Rectangle:\n    def __init__(self, length, width, **kwargs):\n        self.length = length\n        self.width = width\n        super().__init__(**kwargs)\n\n    def area(self):\n        return self.length * self.width\n\n    def perimeter(self):\n        return 2 * self.length + 2 * self.width\n\n# Here we declare that the Square class inherits from \n# the Rectangle class\nclass Square(Rectangle):\n    def __init__(self, length, **kwargs):\n        super().__init__(length=length, width=length, **kwargs)\n\nclass Cube(Square):\n    def surface_area(self):\n        face_area = super().area()\n        return face_area * 6\n\n    def volume(self):\n        face_area = super().area()\n        return face_area * self.length\n\nclass Triangle:\n    def __init__(self, base, height, **kwargs):\n        self.base = base\n        self.height = height\n        super().__init__(**kwargs)\n\n    def tri_area(self):\n        return 0.5 * self.base * self.height\n\nclass RightPyramid(Square, Triangle):\n    def __init__(self, base, slant_height, **kwargs):\n        self.base = base\n        self.slant_height = slant_height\n        kwargs[\"height\"] = slant_height\n        kwargs[\"length\"] = base\n        super().__init__(base=base, **kwargs)\n\n    def area(self):\n        base_area = super().area()\n        perimeter = super().perimeter()\n        return 0.5 * perimeter * self.slant_height + base_area\n\n    def area_2(self):\n        base_area = super().area()\n        triangle_area = super().tri_area()\n        return triangle_area * 4 + base_area\n\n\npprint(RightPyramid.__base__)\npprint(RightPyramid.__mro__)\n\n\npyramid = RightPyramid(base=2, slant_height=4)\npyramid.area()\npyramid.area_2()\n\n\n\nMixin\n\nclass Rectangle:\n    def __init__(self, length, width):\n        self.length = length\n        self.width = width\n\n    def area(self):\n        return self.length * self.width\n\nclass Square(Rectangle):\n    def __init__(self, length):\n        super().__init__(length, length)\n\nclass VolumeMixin: # this is actually a mixin, not perform as a superclass for Cube\n    def volume(self):\n        return self.area() * self.height\n\nclass Cube(VolumeMixin, Square):\n    def __init__(self, length):\n        super().__init__(length)\n        self.height = length\n\n    def face_area(self):\n        return super().area()\n\n    def surface_area(self):\n        return super().area() * 6\n\n\ncube = Cube(2)\ncube.surface_area()\ncube.volume()\n\n\npprint(Cube.__bases__)\npprint(Cube.__mro__)\n\n\n!jupyter nbconvert --config /Users/Natsume/Documents/mynbcfg.py --to markdown \\\n--output-dir /Users/Natsume/Documents/divefastai/Debuggable/nbconvert"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fastai Debuggable",
    "section": "",
    "text": "I would love to learn fastai by experimenting its sources and if possible contribute to them. In this page I would like to present useful tools I built and tinkerings (including contributions) I made during exploration.\nYou can quickly on each page:"
  },
  {
    "objectID": "index.html#a-personal-docs-of-fastcore",
    "href": "index.html#a-personal-docs-of-fastcore",
    "title": "Fastai Debuggable",
    "section": "A personal docs of fastcore",
    "text": "A personal docs of fastcore\n\ndelegates\nofficial docs, how fastai uses it\n\nWhen to use it?\n\n\nWho (which type) use it?\n\n\nHow fastai use it?"
  },
  {
    "objectID": "index.html#useful-tools-i-built",
    "href": "index.html#useful-tools-i-built",
    "title": "Fastai Debuggable",
    "section": "Useful tools I built",
    "text": "Useful tools I built\n\ndebuggable.utils.whatinside\n\nimport fastcore.meta as fm\nwhatinside(fm, dun=True)\n\n\nwhatinside(fm, func=True)\n\n\nwhatinside(fm, clas=True)\n\n\nwhatinside(fm, lib=True)\n\n\nimport fastcore.imports as fi\nwhatinside(fi, dun=True)\n\n\nwhatinside(fi, func=True)\n\n\nwhatinside(fi, clas=True)\n\n\n\ndebuggable.utils.whichversion\n\nwhichversion('nbdev')\n\n\nwhichversion('fastcore')\n\n\nwhichversion('debuggable', req=True)"
  },
  {
    "objectID": "index.html#my-contributions-to-fastcore",
    "href": "index.html#my-contributions-to-fastcore",
    "title": "Fastai Debuggable",
    "section": "My contributions to fastcore",
    "text": "My contributions to fastcore\n\nMy first contrib to fastcore is based on the solution above with Jeremy’s modification"
  },
  {
    "objectID": "index.html#interesting-findings-of-fastcore",
    "href": "index.html#interesting-findings-of-fastcore",
    "title": "Fastai Debuggable",
    "section": "Interesting findings of fastcore",
    "text": "Interesting findings of fastcore"
  }
]