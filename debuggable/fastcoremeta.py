# AUTOGENERATED! DO NOT EDIT! File to edit: ../fastcore/previous/00_delegates.ipynb.

# %% auto 0
__all__ = ['delegates_v1', 'delegates_v2', 'delegates_v3', 'FixSigMeta', 'PrePostInitMeta', 'AutoInit']

# %% ../fastcore/previous/00_delegates.ipynb 4
from fastcore.meta import *
from fastcore.test import *
import inspect
from pprint import pprint

# %% ../fastcore/previous/00_delegates.ipynb 137
def delegates_v1(to=None, # delegates `to` to replace `**kwargs` with its own params
              keep=False, # keep `**kwargs` in the signature or not
              but:list=None): # leave out certain params from the signature
    """
        Decorator: replace `**kwargs` in signature with params from `to`. If `keep=True`and `to` has no `**kwargs` in its signature, a warning of TypeError will be generated.
    """
    if but is None: but = []
    def _f(f):
        if to is None: to_f,from_f = f.__base__.__init__,f.__init__
        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f
        from_f = getattr(from_f,'__func__',from_f)
        to_f = getattr(to_f,'__func__',to_f)
        if hasattr(from_f,'__delwrap__'): return f
        sig = inspect.signature(from_f)
        sigd = dict(sig.parameters)
        k = sigd.pop('kwargs')
            
        s2 = {k:v for k,v in inspect.signature(to_f).parameters.items()
              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}
        sigd.update(s2)

        """
        if to_f has no attr 'lowest_func_no_kwargs', 
        then this to_f must be the first or the lowest function;
        if this to_f has no **kwargs as parameter, then we set the value of attr 'lowest_func_no_kwargs'
        to be to_f itself in string format
        if this to_f has **kwargs as parameter, then set the value of the attr as None
        """
        sigt = inspect.signature(to_f)  # get signature of mid
        sigtd = dict(sigt.parameters)  # make signature a dict
        try:
            from_f.__setattr__("lowest_func_no_kwargs", to_f.lowest_func_no_kwargs)
        except:
            if sigtd.get('kwargs') == None: 
                to_f.__setattr__("lowest_func_no_kwargs", f'{to_f.__name__}')
            else:
                to_f.__setattr__("lowest_func_no_kwargs", None)
            from_f.__setattr__("lowest_func_no_kwargs", to_f.lowest_func_no_kwargs)
        
        if keep: 
            if to_f.lowest_func_no_kwargs != None:  # check lowest_no_kwargs
                print(f"Warning: adding extra kwargs to {from_f.__name__} will cause TypeError to {to_f.lowest_func_no_kwargs}\n")
            sigd['kwargs'] = k
        else: from_f.__delwrap__ = to_f
        from_f.__signature__ = sig.replace(parameters=sigd.values())
        return f
    return _f

# %% ../fastcore/previous/00_delegates.ipynb 152
def delegates_v2(to=None, # delegates `to` to replace `**kwargs` with its own params
              keep=False, # keep `**kwargs` in the signature or not
              but:list=None): # leave out certain params from the signature
    "Compared with v1, delegates_v2 func add a feature to remind users that params from `to` are keyword-only params for `f`."

    if but is None: but = []
    def _f(f):
        if to is None: to_f,from_f = f.__base__.__init__,f.__init__
        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f
        from_f = getattr(from_f,'__func__',from_f)
        to_f = getattr(to_f,'__func__',to_f)
        if hasattr(from_f,'__delwrap__'): return f
        sig = inspect.signature(from_f)
        sigd = dict(sig.parameters)
        k = sigd.pop('kwargs')
            
        s2 = {k:v for k,v in inspect.signature(to_f).parameters.items()
              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}
        sigd.update(s2)
        """
        put s2's keys into a list
        print a warning message: from_f has the s2's keys as Keyword Only params
        """
        keyword_only_list = [i for i in s2.keys()]
        print(f"{from_f.__name__} has {keyword_only_list} as keyword only params, not to be used as positional.")

        """
        if to_f has no attr 'lowest_func_no_kwargs', 
        then this to_f must be the first or the lowest function;
        if this to_f has no **kwargs as parameter, then we set the value of attr 'lowest_func_no_kwargs'
        to be to_f itself in string format
        if this to_f has **kwargs as parameter, then set the value of the attr as None
        """
        sigt = inspect.signature(to_f)  # get signature of mid
        sigtd = dict(sigt.parameters)  # make signature a dict
        try:
            from_f.__setattr__("lowest_func_no_kwargs", to_f.lowest_func_no_kwargs)
        except:
            if sigtd.get('kwargs') == None: 
                to_f.__setattr__("lowest_func_no_kwargs", f'{to_f.__name__}')
            else:
                to_f.__setattr__("lowest_func_no_kwargs", None)
            from_f.__setattr__("lowest_func_no_kwargs", to_f.lowest_func_no_kwargs)
        
        if keep: 
            if to_f.lowest_func_no_kwargs != None:  # check lowest_no_kwargs
                print(f"Warning: adding extra kwargs to {from_f.__name__} will cause TypeError to {to_f.lowest_func_no_kwargs}\n")
            sigd['kwargs'] = k
        else: from_f.__delwrap__ = to_f
        from_f.__signature__ = sig.replace(parameters=sigd.values())
        return f
    return _f

# %% ../fastcore/previous/00_delegates.ipynb 158
def delegates_v3(to=None, # delegates `to` to replace `**kwargs` with its own params
              keep=False, # keep `**kwargs` in the signature or not
              but:list=None): # leave out certain params from the signature
    "Compared with v1, delegates_v2 func add a feature to remind users that params from `to` are keyword-only params for `f`."

    if but is None: but = []
    def _f(f):
        if to is None: to_f,from_f = f.__base__.__init__,f.__init__
        else:          to_f,from_f = to.__init__ if isinstance(to,type) else to,f
        from_f = getattr(from_f,'__func__',from_f)
        to_f = getattr(to_f,'__func__',to_f)
        if hasattr(from_f,'__delwrap__'): return f
        sig = inspect.signature(from_f)
        sigd = dict(sig.parameters)
        k = sigd.pop('kwargs')
            
        s2 = {k:v for k,v in inspect.signature(to_f).parameters.items()
              if v.default != inspect.Parameter.empty and k not in sigd and k not in but}
        """
        Change type from POSITIONAL_OR_KEYWORD to KEYWORD_ONLY for all parameters in s2
        """
        s2 = {name: param.replace(kind=inspect.Parameter.KEYWORD_ONLY) for name, param in s2.items()} 
        
        sigd.update(s2)
        """
        put s2's keys into a list
        print a warning message: from_f has the s2's keys as Keyword Only params
        """
        keyword_only_list = [i for i in s2.keys()]
        print(f"{from_f.__name__} has {keyword_only_list} as keyword only params, not to be used as positional.")

        """
        if to_f has no attr 'lowest_func_no_kwargs', 
        then this to_f must be the first or the lowest function;
        if this to_f has no **kwargs as parameter, then we set the value of attr 'lowest_func_no_kwargs'
        to be to_f itself in string format
        if this to_f has **kwargs as parameter, then set the value of the attr as None
        """
        sigt = inspect.signature(to_f)  # get signature of mid
        sigtd = dict(sigt.parameters)  # make signature a dict
        try:
            from_f.__setattr__("lowest_func_no_kwargs", to_f.lowest_func_no_kwargs)
        except:
            if sigtd.get('kwargs') == None: 
                to_f.__setattr__("lowest_func_no_kwargs", f'{to_f.__name__}')
            else:
                to_f.__setattr__("lowest_func_no_kwargs", None)
            from_f.__setattr__("lowest_func_no_kwargs", to_f.lowest_func_no_kwargs)
        
        if keep: 
            if to_f.lowest_func_no_kwargs != None:  # check lowest_no_kwargs
                print(f"Warning: adding extra kwargs to {from_f.__name__} will cause TypeError to {to_f.lowest_func_no_kwargs}\n")
            sigd['kwargs'] = k
        else: from_f.__delwrap__ = to_f
        from_f.__signature__ = sig.replace(parameters=sigd.values())
        return f
    return _f

# %% ../fastcore/previous/00_delegates.ipynb 262
class FixSigMeta(type):
    "A metaclass that fixes the signature on classes that override `__new__` of `type`"
    def __new__(cls, name, bases, dict):
        print("============================\nrunning metaclass FixSigMeta.__new__\n")
        print(f"local variables are:\n")
        pprint(locals())
        
        # create new obj using type.__new__
        res = super().__new__(cls, name, bases, dict)
        print(f"\nUsing type.__new__ to create a class instance of type: {res}")
        
        pprint(f"{res.__name__}'s type should and is: {type(res)}")
        print(f"\n{res.__name__}'s inheritance tree: {res.__mro__}")
        print(f"In other words, {res.__name__}'s bases are: {res.__bases__}\n")
        print(f"\ndoes {res.__name__} have attr `__signature__`:{hasattr(res, '__signature__')}")
        pprint(inspect.signature(res))
        
        
        print(f"if {res.__name__} has its own __init__, then update with __init__'s signature")
        if res.__init__ is not object.__init__: res.__signature__ = _rm_self(inspect.signature(res.__init__))
        if hasattr(res, '__signature__'):
            print(f"\nnow, {res.__name__}.__signature__ becomes:{res.__signature__}")
        
        print("\nend of metaclass FixSigMeta.__new__\n============================")
        return res # and the object is passed on

# %% ../fastcore/previous/00_delegates.ipynb 279
class PrePostInitMeta(FixSigMeta): # make a subclass of metaclass FixSigMeta, is now a metaclass
    "A metaclass that calls optional `__pre_init__` and `__post_init__` methods"
    
    print(f"==================\nRunning inside PrePostInitMeta\n")
    print(f"PrePostInitMeta will inherit __new__ and __init__ from FixSigMeta")
    
    # override the metaclass FixSigMeta.__call__
    def __call__(cls, *args, **kwargs):
        print(f"==================\nRunning PrePostInitMeta.__call__\n")
        print(f"local variables:")
        pprint(locals())
        
        # let the cls to create an object instance based on cls, and assign obj to res
        res = cls.__new__(cls) # res is a class
        print(f"\nTask 1 running res = {cls.__name__}.__new__(cls) to create an obj instance of {cls.__name__}: {res}")
        
        if type(res)==cls: # if res is an instance of cls
            
            print(f"\nTask 2: \nif {res.__class__.__name__} object is an instance of {cls.__name__} and \
{res.__class__.__name__} has '__pre_init__' attr, then run {res.__class__.__name__}.__pre_init__ on the object.")
            # if the instance class has __pre__init__, then run this func
            if hasattr(res,'__pre_init__'): res.__pre_init__(*args,**kwargs)
                
            print(f"\nTask 3: \nif {res.__class__.__name__} object is an instance of {cls.__name__}, \
then run {res.__class__.__name__}.__init__ on the object.")
            res.__init__(*args,**kwargs) # call res.__init__
            
       
            print(f"\nTask 4: \nif {res.__class__.__name__} object is an instance of {cls.__name__} and \
{res.__class__.__name__} has '__post_init__' attr, then run {res.__class__.__name__}.__post_init__ on the object.")
            if hasattr(res,'__post_init__'): res.__post_init__(*args,**kwargs)

            print(f"\nfinally, return the initialized object of class {res.__class__.__name__}")
            print(f"====================end of PrePostInitMeta.__call__")
            return res # return obj
    print(f"====================end of PrePostInitMeta class")

# %% ../fastcore/previous/00_delegates.ipynb 296
# AutoInit is a class created by metaclass PrePostInitMeta, not type
# AutoInit inherit from object, not PrePostInitMeta
# when AutoInit makes an object instance, 
# the PrePostInitMeta.__call__ makes use of __pre_init__, __init__, __post_init__ of AutoInit
# if AutoInit has them

# but right now, only PrePostInitMeta.__new__ is called to create a class instance of itself
# AntoInit is not a metaclass, but a class instance of PrePostInitMeta
class AutoInit(metaclass=PrePostInitMeta):
    "Same as `object`, but no need for subclasses to call `super().__init__`"
    
    print(f"\n=========Running inside AutoInit class\n")
    
    def __pre_init__(self, *args, **kwargs): 
        print(f"\n====Running inside AutoInit.__pre_init__: \n")
        
        super().__init__(*args, **kwargs)
        print(f"Now, object.__init__ is called to initialize, so that subclasses of AutoInit \
        not need to run this line of code.")
